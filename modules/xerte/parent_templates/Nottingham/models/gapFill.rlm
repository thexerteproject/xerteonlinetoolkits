	<PG title="Gap Fill" name="gapFill">		<SCR name="getPageID"><![CDATA[pageIcon = icon.parentNode.clip();if (rootIcon.projMode == "dev"){  // Page Wizard  pageIcon.templateData = pageIcon.extXML.toObject();  pageIcon.templateData = pageIcon.templateData.pageWizard[0];} else {  // Toolkits  myXML = new XML(extXML.firstChild.childNodes[rootIcon.getPageIndex() - pgOffset]);  pageIcon.templateData = myXML.toObject();}rootIcon.setTitleText(templateData.learningObject[0].name);// handle multiple page data definitions in a project if (rootIcon.projectPageIndex == undefined){     rootIcon.projectPageIndex = 0;}// check if this page has a definition for the current project index and default to 0 if notif (pageIcon.templateData.gapFill[rootIcon.projectPageIndex].name == undefined){  projPI = 0;} else {  projPI = rootIcon.projectPageIndex; }  ts = STYLES.inputSize;panelWidth = pageIcon.templateData.gapFill[projPI].panelWidth;if (panelWidth == "Small"){  panelW = 300;  textW = 440;} else if (panelWidth == "Medium"){  panelW = 450;  textW = 290;} else if (panelWidth == "Large"){  panelW = 600;  textW = 150;} else {  panelW = 760;  textW = 0;}if (pageIcon.templateData.gapFill[projPI].narration != undefined){  narration = pageIcon.templateData.gapFill[projPI].narration;  rootIcon.broadcast('showAudio');}]]></SCR>		<DIS h="474" w="panelW" tabIndex="-1" id="panel" name="panel" x="780 - panelW" y="20" type="ext" url="templatePath + 'common/whitePanel.swf'"><![CDATA[]]></DIS>		<DIS id="textBlock" h="10" name="text" x="20" y="20" w="textW" type="text"><![CDATA[{pageIcon.templateData.gapFill[projPI].text}]]></DIS>		<SCR name="preprocess"><![CDATA[//preparse the textstr = pageIcon.templateData.gapFill[projPI].passage;str = replace(str, '  ', ' ');//str = replace(str, '\r', '');//if drag and drop, then add padding to the wordsif (pageIcon.templateData.gapFill[projPI].interactivity == 'Drag Drop'){  token = '¬¬¬¬¬¬¬¬';    for (i = 0; i < str.length; i++){      if (str.substr(i,1) == '|'){ //add n random chars to the string after the first | of a pair            wordLength = str.indexOf('|', i + 1) - i - 1;      if (wordLength <= 4){        padding = 4 - wordLength;      } else if (wordLength <= 8){        padding = 8 - wordLength;      } else {         padding = Math.floor(Math.random() * 5);      }            tempStr = '|' + token.substr(0, padding);      str = str.substr(0,i) + tempStr + str.substr(i + 1);      i = str.indexOf('|', i + 1);    }  }}//done padding for drag and drop - the rest of the code is the samelbls = '';paras = str.split('\r');nIndex = -1;notes = new Array();for (j = 0; j < paras.length; j++){    arr = paras[j].split(' ');    for (i = 0; i < arr.length; i++){        nIndex++;    if (arr[i].indexOf('|') != -1){      note = new Object();      note.index = nIndex;      note.start = arr[i].indexOf('|');      note.end = arr[i].lastIndexOf('|') - 2;      note.string = arr[i].substr(note.start + 1, note.end - note.start + 1);      note.string = replace(note.string, '¬', '');            lbls += note.string + ' ';            notes.push(note);    }  }}str = replace(str, '|', '');//add any additional distractorsif (pageIcon.templateData.gapFill[projPI].noise != undefined){  lbls += pageIcon.templateData.gapFill[projPI].noise;}]]></SCR>		<DIS tabIndex="-1" id="mainText" name="passage" x="panel._x + 20" y="panel._y + 20" w="panelW - 40" h="10" type="text"><![CDATA[{str}]]></DIS>		<SCR name="setupInteraction"><![CDATA[n = 0;words = mainText.breakApart(3,7,false, false);targets = new Array();for (i = 0; i < notes.length; i++){  word = words[notes[i].index];    word.tabIndex = -1;    o = word.getRangeMetrics(notes[i].start, notes[i].end);   word.createEmptyMovieClip('mask',9);  word.mask.beginFill(0xFFFF99,100);  word.mask.drawRect(o.start + 2, 2, o.end, o.height);    word.string = notes[i].string;  word.xStart = o.start;  word.xWidth = o.end;    targets.push(word);}]]></SCR>		<DIS tabIndex="-1" textColour="#FF0000" id="lbls" name="lbls" x="mainText._x" y="mainText._y + mainText._height + 10" w="300" h="10" type="text"><![CDATA[{lbls}]]></DIS>		<SCR isFunc="1" name="fHideHint"><![CDATA[hint.removeMovieClip();]]></SCR>		<SCR name="makeInteraction"><![CDATA[//what type of interaction is this?if (pageIcon.templateData.gapFill[projPI].interactivity == 'Drag Drop'){  labels = lbls.breakApart(13,33,true,true);    for (i = 0; i < labels.length; i++){    labels[i].string = labels[i].txt.text;  }    //randomise position  labels.randomize();  initX = 0;  initY = 0;  for (i = 0; i < labels.length; i++){      labels[i]._x = initX;    labels[i]._y = initY;      initX += labels[i]._width + 3;      if (initX > mainText._width - labels[i]._width){      initX = 0;      initY += 20;    }    //store the initX and Y for replacement    labels[i].initX = labels[i]._x;    labels[i].initY = labels[i]._y;  }  if (icon.attributes.built != 'true'){    icon.nextSibling.firstChild.removeNode();    icon.attributes.built = 'true';  }} else { //fill in the blnk  lbls.removeMovieClip();  icon.nextSibling.childNodes[1].removeNode();    if (icon.attributes.built != 'true'){        icon.nextSibling.firstChild.duplicate(targets.length - 1);    icon.attributes.built = 'true';    for ( i = 0; i < targets.length; i++){      icon.nextSibling.childNodes[i].attributes.answer = targets[i].string;    }  }}lbls.tabChildren = false;count = 0;]]></SCR>		<INT id="gapInt" name="mainInteraction" perpetual="1">			<RES name="protoTextEntry" type="textEntry" x="mainText._x +  targets[icon.index()]._x+ targets[icon.index()].xStart" y="mainText._y + targets[icon.index()]._y" w="targets[icon.index()].xWidth + 4" h="100" phrase="" scrolling="0" border="0" erase="1" exit="0">				<SCR name="onMatch"><![CDATA[tf = icon.parentNode.clip();ans = tf.XMLElement.attributes.answer;//correct...if (ans == tf.text){    tf.border = false;  tf.type = "dynamic";  tf.htmlText = '<font color="#006600">' + tf.text + '</font>';    count++;    targets[icon.parentNode.index()].mask.clear();    Selection.setFocus(icon.parentNode.nextSibling.clip());    if (count == targets.length){    gapInt.broadcast("showFeedback");  }  } else { //not correct yethint.removeMovieClip();  if (tf.text != ans.substr(0, tf.text.length)){    tf.attempts++;  }             if (tf.attempts >= Math.floor(ans.length / 3)){     gapInt.broadcast('showHint');  }}]]></SCR>			</RES>			<RES name="onWordDropped" type="event" eventName="onWordDropped" icon="lbls" erase="1" exit="0">				<SCR name="test"><![CDATA[//check all targetssuccess = false;for (i = 0; i < targets.length; i++){  if (lbls.wordDropped.hitTest(targets[i]) && lbls.wordDropped.string == targets[i].string){    matchedTarget = targets[i];    success = true;    count++;  }}if (success == true){  lbls.wordDropped._x = matchedTarget.xStart + matchedTarget._x - (lbls._x - mainText._x);  lbls.wordDropped._y = matchedTarget._y - (lbls._y - mainText._y);  lbls.wordDropped.onPress = fnull;  lbls.wordDropped.useHandCursor = false;  lbls.wordDropped.colourText('#006600');  } else {  lbls.wordDropped.animate(lbls.wordDropped.initX,lbls.wordDropped.initY,10,'quadBez',1);}if (count == targets.length){  gapInt.broadcast("showFeedback");  }]]></SCR>			</RES>			<RES name="showFeedback" type="event" eventName="showFeedback" icon="gapInt" erase="1" exit="0">				<DIS transition="wipe('in', 0.5, 'None', 'easeNone')" name="feedback" x="380" y="mainText._y + mainText._height + 20" w="400" h="10" type="text"><![CDATA[{pageIcon.templateData.gapFill[projPI].feedback}]]></DIS>			</RES>			<RES name="showHint" type="event" eventName="showHint" icon="gapInt" erase="1" exit="0">				<SCR name="showHint"><![CDATA[hintStr = '';if (tf.hinted != true){    if (tf.attempts > Math.floor(ans.length / 3)){     hintStr = ans.substr(0,1);    for (i = 1; i < ans.length; i++){      hintStr += '_';    }  }    //last letter  if (tf.attempts > Math.floor(ans.length / 1.5)){     hintStr = ans.substr(0,1);    for (i = 1; i < ans.length - 1; i++){      hintStr += '_';    }    hintStr += ans.substr(ans.length - 1);  }    //random letter  if (tf.attempts > ans.length){     hintStr = ans.substr(0,1);        for (i = 1; i < ans.length - 1; i++){          if (Math.random() < 0.6){        hintStr += '_';      } else {        hintStr += ans.substr(i,1);      }    }    hintStr += ans.substr(ans.length - 1);    tf.hinted = true;  }  tf.hintString = hintStr;}]]></SCR>				<DIS id="hint" name="hint" x="tf._x" y="tf._y - 22" w="400" h="10" type="text"><![CDATA[{tf.hintString}]]></DIS>				<SCR name="draw"><![CDATA[if (tf.hintString != ''){  hint.beginFill(0xFFFFCC,100);  hint.lineStyle(0,0x333333,100);  hint.drawRect(0,2,hint.getTextWidth(),16);}]]></SCR>			</RES>		</INT>		<SCR name="restrictTextFields"><![CDATA[for ( i = 0; i < targets.length; i++){  tA = icon.previousSibling.childNodes[i].clip();  tA.maxChars = targets[i].string.length;  tA.multiline = false;  tA.wordwrap = false;  tA.attempts = 0;  tA.onSetFocus = fHideHint;}]]></SCR>	</PG>