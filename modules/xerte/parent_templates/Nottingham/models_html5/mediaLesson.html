<script type="text/javascript">
/**
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.

 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
	
	// pageChanged & sizeChanged functions are needed in every model file
	// other functions for model should also be in here to avoid conflicts
	var mediaLesson = new function() {
		var	$panelHolder,
			plugins = ["mediaconstructor", "textplus", "subtitleplus", "xot", "mediaplus", "mcq", "slides", "sortholder"], // list of popcorn plugins to load
			css = ["subtitleplus", "mcq", "overlaygeneric", "slides"]; // list of popcorn plugin css to load
		
		// function called every time the page is viewed after it has initially loaded
		this.pageChanged = function() {
            this.panelbaseid = "panel_" + x_currentPage + '_';

            $panelHolder = $("#panelHolder");
			
			if ($("#pageContents").data("mediaElement") != undefined) {
				$("#pageContents").data("mediaElement").setCurrentTime(0);
			}
			
			$(".embed").each(function() {
				$(this).data("popcornInstance").pause();
			});
			
			// if audio is in footer (outside pageHolder) it will need reloading on every page change
			if ($("#pageContents").data("audioBar") == true && $x_footerBlock.find(".mainMedia").length == 0) {
				this.loadAudioInFooter();
			}
            this.setUp();
		};
		
		// function called from mediaPlayer.js when video player has been set up
		this.mediaFunct = function(mediaElement, mediaSrc) {
			if ($(mediaElement).closest(".mainMedia").length != 0) {
				$("#pageContents").data("mediaElement", mediaElement);
			}
		};
		
		// function called every time the size of the LO is changed
		this.sizeChanged = function() {
            $panelHolder = $("#panelHolder");
            var panels = $panelHolder.find(".panel");

            if (panels.length == 2)
			{
                var panelLayout = x_currentPageXML.getAttribute("layout");
                if (panelLayout == "grid") {
                    var $mainHolder = $("#x_mainHolder");
                    // Two panels. If in portrait mode, stack vertical, otherwise show horizontal
                    // Use mainHolder, because height of panelHolder is not set on touch/mobile devices
                    if ($mainHolder.width() >= $mainHolder.height()) {
                        $panelHolder.find(".panel").removeClass("tileV fullW").addClass("tileH fullH");
                    }
                    else {
                        $panelHolder.find(".panel").removeClass("tileH fullH").addClass("tileV fullW");
                    }
                }
            }
			this.resizePanels();
		};
		
		this.resizePanels = function() {
			var zoomLevel = window.devicePixelRatio;
			var zoomCorrection = -1/zoomLevel;
		    // make sure no scroll bars are on screen during panel sizing
			var curroverflow = $x_pageHolder.css("overflow");
			$x_pageHolder.css("overflow", "hidden");
			var numTileH = $("#panelHolder .panel.tileH").length,
				numTileV = $("#panelHolder .panel.tileV").length;
			
			if (x_currentPageXML.getAttribute("layout") == "grid" && $("#panelHolder .top").length > 0) {
				numTileH = $("#panelHolder .top .panel.tileH").length;
			}

			if ($panelHolder.find(".panel").length == 1) {
				$panelHolder.find(".panel")
						.width(Math.floor($x_pageHolder.width() - ($x_pageDiv.outerWidth(true) - $x_pageDiv.width()) - ($panelHolder.find(".panel").outerWidth(true) - $panelHolder.find(".panel").width())))
						.height(Math.floor(x_getAvailableHeight([$panelHolder.find(".panel")])));

			} else {
				$panelHolder.find(".panel.tileH")
						.width(Math.floor(($x_pageHolder.width() - ($x_pageDiv.outerWidth(true) - $x_pageDiv.width()) - (($panelHolder.find(".panel.tileH").outerWidth(true) - $panelHolder.find(".panel.tileH").width()) * (numTileH-1)) - ($panelHolder.find(".panel.tileH").outerWidth() - $panelHolder.find(".panel.tileH").width())) / numTileH))
						.css('height', '');

				$panelHolder.css("margin-top", $("#infoHolder .accTitle").height() + parseFloat($("#infoHolder .accTitle").css("padding-top")) * 2);

				$panelHolder.find(".panel.tileV")
						.height(Math.floor((x_getAvailableHeight() - (($panelHolder.find(".panel.tileV").outerHeight(true) - $panelHolder.find(".panel.tileV").height()) * (numTileV-1)) - ($panelHolder.find(".panel.tileV").outerHeight() - $panelHolder.find(".panel.tileV").height())) / numTileV))
						.css('width', '');

				$panelHolder.find(".panel.fullH")
						.height(Math.floor(x_getAvailableHeight([$panelHolder.find(".panel.fullH")])));

				$panelHolder.find(".panel.halfH")
						.height(Math.floor(x_getAvailableHeight([$panelHolder.find(".panel.halfH")], [$panelHolder.find(".panel.halfH").outerHeight() - $panelHolder.find(".panel.halfH").height()]) / 2));
			}

			$x_pageHolder.css("overflow", curroverflow);
			
			this.resizeMedia();
		};
		
		// function resizes media controls
		this.resizeMedia = function($holder) {
			// resize if the media is now the wrong size for its holder
			// this is done by manually triggering the window resize event (mediaelement.js listens to this event)
			
			var triggerResize = true;
			$(".popcornMedia video").each(function(i) {
				var	$this = $(this),
					$popcornMedia = $this.closest(".popcornMedia");
				var titleHeight = $(".panelTitle").outerHeight(true);
				
				var tempW = $popcornMedia.data("max-width");
				var tempH = $popcornMedia.data("max-height") - titleHeight;
				if (tempW > $popcornMedia.closest(".panel").width()) {
					var scale = $popcornMedia.closest(".panel").width() / tempW;
					tempW = $popcornMedia.closest(".panel").width();
					tempH = Math.floor(tempH * scale);
				}
				if (tempH > $popcornMedia.closest(".panel").height() - titleHeight) {
					var scale = ($popcornMedia.closest(".panel").height() - titleHeight) / tempH;
					tempH = $popcornMedia.closest(".panel").height() - titleHeight;
					tempW = Math.floor(tempW * scale);
				}
				
				$popcornMedia.css({
						"max-width"	:tempW,
						"max-height":tempH
					});

				$popcornMedia.children().each(function(i, e){
					$(this).css("max-height", $(this).parent().css("max-height"));
				});

				if ($this.width() != $popcornMedia.width() && triggerResize == true) {
					triggerResize = false;
					$x_window.resize();
				}
				if ($popcornMedia.next().hasClass("transcriptHolder")) {
					$popcornMedia.next().width($popcornMedia.width());
				}
			});
			var ratio = 16 / 9;
			if ($(x_currentPageXML).children("mediaPanel").attr("aspectRatio") != undefined)
			    ratio = parseFloat($(x_currentPageXML).children("mediaPanel").attr("aspectRatio"));
		    $(".popcornMedia.embed").each(function(i) {
		    	resizeEmbededMedia($(this), {ratio: ratio});
			});
			
			$(".audioImg").each(function() {
				var $this = $(this);
				x_scaleImg($this, $this.closest(".panel").width(), $this.closest(".panel").height() - x_audioBarH, true, false);
				$this.closest(".mediaHolder").width($this.width());
			});
			
			$(".popcornMedia audio").each(function(i) {
				var audioBarW = 0;
				$(this).closest(".mejs-inner").find(".mejs-controls").children().each(function() {
					audioBarW += $(this).outerWidth();
				});
				if (audioBarW != $(this).closest(".popcornMedia").width() && triggerResize == true) {
					triggerResize = false;
					$x_window.resize();
				}
			});
			
			$panelHolder.find(".panel .fullH").each(function() {
				mediaLesson.resizeContent($(this));
			});
		}
		
		// function resizes contentBlocks that should fill available space
		this.resizeContent = function($holder) {
			var excludeH = $holder.data("exclude") != undefined ? $holder.data("exclude").outerHeight(true) : 0,
				$panel = $holder.parents(".panel");
			
			// if content is overlay on media then use media for max sizes
			if ($holder.parents(".panelContent").length == 0) {
				$panel = $holder.parents(".overlay").parent();
			}
			
			if (!$holder.data("max")) {
				$holder.height($panel.height() - (parseInt($panel.css("padding-top")) * 2) - $panel.find(".panelTitle").outerHeight() - excludeH);
			} else {
				$holder.css("max-height", $panel.height() - (parseInt($panel.css("padding-top")) * 2) - $panel.find(".panelTitle").outerHeight() - excludeH);
			}
			
			if ($holder.hasClass("googlemapHolder")) {
				//google.maps.event.trigger($holder.find(".gm-style")[0], "resize");
			}
		}

		this.isFullScreen = function()
		{
            if (document.fullscreenElement ||    // alternative standard method
                document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ) {  // current working methods
                return true;
            }
            else {
                return false;
			}
		};
        this.exitFullScreen = function() {
            if (document.fullscreenElement ||    // alternative standard method
                document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement ) {  // current working methods
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                }
            }
        };

		this.leavePage = function () {

			if ($(x_currentPageXML).children("mediaPanel").attr("media") != undefined && $(x_currentPageXML).children("mediaPanel").attr("media") != "") {
				$this = this;
				$(".embed").each(function() {
					$(this).data("popcornInstance").pause();
				});
				// Finish tracking of video
				// This will also account for last video segment, so there might be race conditions
				// Also we do let popcorn handle the destruction (doNotCloseTracking parameter in loadMedia) of popcorn, so we need to do that here at the end
				document.dispatchEvent(new Event('leavepage'));
				// Calculate page score
				var questions = x_currentPageXML.getElementsByTagName("synchMCQ");
				var numOfQuestions = questions.length;
				var trackVideo = x_currentPageXML.getAttribute('trackVideo') === 'yes' ||
						x_currentPageXML.getAttribute('trackVideo') === 'only_video' ||
						x_currentPageXML.getAttribute('trackVideo') === 'no_mcqs' && numOfQuestions == 0;

				score = 0;
				for (var i = 0; i < numOfQuestions; i++) {
					if ($this.questions[i]) {
						score++;
					}
				}
				mcqScore = score / numOfQuestions;

				let videoState = $this.popcornInstance.videoState;
				let progress = 0;
				if (videoState != undefined && trackVideo) {
					// Calculate progress
					progress = XThelperDetermineProgress(videoState);
				}
				let trackVideoSetting = 'no_mcqs';
				if (x_currentPageXML.getAttribute('trackVideo') != undefined)
				{
					trackVideoSetting = x_currentPageXML.getAttribute('trackVideo');
				}
				switch (trackVideoSetting) {
					case 'yes':
						totalScore = (mcqScore + progress) / 2;
						break;
					case 'only_video':
						totalScore = progress;
						break;
					case 'no_mcqs':
						if (numOfQuestions == 0) {
							totalScore = progress;
						} else {
							totalScore = mcqScore;
						}
						break;
					case 'no':
						if (numOfQuestions == 0) {
							// count as page with no interactions
							totalScore = 1;
						} else {
							totalScore = mcqScore;
						}
				}
				totalScore = Math.round(totalScore * 10000.0) / 100.0;
				XTSetPageScore(x_currentPage, totalScore);

				//Destroy popcornInstance
				if ($this.popcornInstance) {
					removeEvents($this.popcornInstance);
					$this.popcornInstance.destroy();
				}
				$("div.popcornMedia").remove();
			}
		};

		this.loadMedia = function($holder, type, data) {
			loadMedia($holder, type, data);
		}

		this.init = function() {
            this.panelbaseid = "panel_" + x_currentPage + '_';
			if (!!document.createElement("canvas").getContext) {
				// load popcorn library and plugins 
				var loadFiles = true;
                if(xot_offline) {
                    /* files are already loaded statically */
                    loadFiles = false;
                }
				// comment out next loop and always load popcorn files
				// This is because popcorn breaks if you have a mediaLesson
				// and then a nav page which also loads popcorn with a different set of plugins
				// Any mediaLesson after that will not work anymore
				/*
				for (var i=0; i<x_pageInfo.length; i++) {
					if (i != x_currentPage && x_pageInfo[i].type == x_pageInfo[x_currentPage].type && x_pageInfo[i].built != false) {
						// a page of this type has already been loaded - don't reload popcorn files
						loadFiles = false;
						break;
					}
				}
				*/
				if (loadFiles == true ) {
					this.loadPopcorn();
				} else {
					this.setUp();
				}

			} else {
				$("#infoHolder, #panelHolder, #contentCover").remove();
				$("#pageContents").append('<p class="alert">' + x_getLangInfo(x_languageData.find("errorBrowser")[0], "label", "Your browser does not fully support this page type") + '</p>');
				x_pageLoaded();	
			}	
		}
		
		this.initTracking = function() {
			var questions = x_currentPageXML.getElementsByTagName("synchMCQ");
            var numOfQuestions = questions.length;
			// Number the quesion in the order they appear in the editor

            trackinglabel = $('<div>').html(x_currentPageXML.getAttribute("name")).text();
            if (x_currentPageXML.getAttribute("trackinglabel") != undefined && x_currentPageXML.getAttribute("trackinglabel") != "")
            {
                trackinglabel = x_currentPageXML.getAttribute("trackinglabel");
            }
			mediaLesson.questions = [];
			var nr = 0;
			$(questions).each(function(key, value){
			    value.setAttribute("total_questions", numOfQuestions);
				value.setAttribute("tracking_nr",nr);
				mediaLesson.questions[nr] = false;
				nr++;
			});
			this.weighting = 1.0;
            if (x_currentPageXML.getAttribute("trackingWeight") != undefined)
            {
                this.weighting = x_currentPageXML.getAttribute("trackingWeight");
            }

            window.correctQuestions = 0;
            XTSetPageType(x_currentPage, 'numeric',numOfQuestions , this.weighting);
            //XTVideo(x_currentPage, trackinglabel, "", "initialized", vidFullWatched, x_currentPageXML.getAttribute("grouping"));
		};
				
		// function loads the popcorn files
		this.loadPopcorn = function() {
			$.getScript(x_templateLocation + "common_html5/js/popcorn/popcorn-complete.js")
				.done(function() {
					mediaLesson.loadPlugins();
				})
				.fail(function( jqxhr, settings, exception ) {
					console.log("Failed to load Popcorn.js & plugins" + exception);
				});
		}
		this.loadPlugins = function() {
			var i = 0;
			plugins.forEach(function (plugin) {
				var fileLocation = "common_html5/js/popcorn/plugins/popcorn." + plugin;
				if (jQuery.inArray(plugin, css) != -1) {
					x_insertCSS(x_templateLocation + fileLocation + ".css");
				}
				$.getScript(x_templateLocation + fileLocation + ".js")
					.done(function(setttings, textStatus){
						if (++i >= plugins.length)
							mediaLesson.setUp();
					})
					.fail(function( jqxhr, settings, exception ) {
						console.log("Failed to load plugin:" + exception);
					});
			});
		}

		// function called when popcorn.js & plugin files have all loaded
		this.setUp = function() {
			// _____ SORT PAGE LAYOUT _____
			
			$panelHolder = $("#panelHolder");

			// Clear panelholder
			$panelHolder.html("");
			
			var	panelData = $(x_currentPageXML).children(),
				panelLayout = x_currentPageXML.getAttribute("layout");
			
			var	mediaFile = $(x_currentPageXML).children("mediaPanel").attr("media"),
				mediaType = "video",
				maxPanels = 4,
				mediaPanelIndex;

			// get index of media panel
			for (var i=0; i<panelData.length; i++) {
				if (panelData[i].nodeName == "mediaPanel") {
					mediaPanelIndex = i;
					break;
				}
			}
			
			// get type of media (video/audio)
			if (mediaFile.indexOf(".mp3") != -1) {
				mediaType = "audio";
				
				// will audio appear in its own panel or across the bottom like narration?
				var audioPosition = panelData[mediaPanelIndex].getAttribute("audioPosition") == "bottom" && (panelData[mediaPanelIndex].getAttribute("audioImage") == "" || panelData[mediaPanelIndex].getAttribute("audioImage") == undefined) ? "bottom" : "panel";
				
				if (audioPosition == "bottom") {
					$("#pageContents").data("audioBar",true);
					this.popcornInstance = this.loadAudioInFooter();
					mediaPanelIndex = -1;
				}
				
			} else if (mediaFile.indexOf(".") == -1) {
				// no media
				mediaType = undefined;
				panelData.splice(mediaPanelIndex, 1);
				mediaPanelIndex = -1;
			}
			
			// if media is in a panel then make sure the number of panels doesn't exceed maxPanels
			if (mediaPanelIndex != -1 && panelData.length > maxPanels) {
				if (mediaPanelIndex >= maxPanels) {
					panelData.splice(maxPanels - 1, 0, panelData[mediaPanelIndex]);
					panelData.splice(mediaPanelIndex + 1, 1);
					mediaPanelIndex = maxPanels - 1;
				}
				panelData.splice(maxPanels, panelData.length - maxPanels);
			}
			
			// set up accordion if there's some intro text
			if (x_currentPageXML.getAttribute("intro") != "" && x_currentPageXML.getAttribute("intro") != undefined) {
				var $contentCover = $("#contentCover");
				$contentCover
					.css("background-image", 'url("' + x_templateLocation + 'common_html5/highlight.png")')
					.hide();
				
				var $infoHolder = $("#infoHolder"),
					closeTxt = x_currentPageXML.getAttribute("introClose") != undefined && x_currentPageXML.getAttribute("introClose") != "" ? x_currentPageXML.getAttribute("introClose") : "close";
				
				$infoHolder.find(".accContent").html('<div>' + x_addLineBreaks(x_currentPageXML.getAttribute("intro")) + '</div><div class="closeTxt"><a href="#">' + closeTxt + '</a></div>');
				$infoHolder.find(".accTitle a").html(x_currentPageXML.getAttribute("introTitle"));
				
				$infoHolder.accordion({
					icons: {
						header: "fa fa-x-acc-hide",
						activeHeader: "fa fa-x-acc-show"
					},
					collapsible:	true,
					heightStyle:	"content",
					beforeActivate:function(event, ui){
						if($(this).find("h3").hasClass("ui-state-active")) { //  close
							$contentCover.fadeOut();
						} else { // open
							$contentCover.fadeIn();
						}
					}
				});
				
				$infoHolder.find(".closeTxt a").add($contentCover).on("click", function() {
					$infoHolder.accordion("option", "active", false);
				});

				if ($infoHolder.accordion("option", "active") !== false) {
					$contentCover.show();
				}

			} else {
				// no introduction text - remove accordion
				$("#infoHolder").remove();
				$("#contentCover").hide();
			}
			
			// create all panels, including the overlay panel
			for (var i=0; i<panelData.length; i++) {
				var title = "";
				// give the panel a name
				if (panelData[i].getAttribute("name") != "") {
                    title = '<h3 class="panelTitle">' + panelData[i].getAttribute("name") + '</h3>';
				}
				// mark the overlay panel and all its relevant children as such
				if (panelData[i].nodeName == "overlayPanel") {
					$(panelData[i].children).each(function(j){
						if (this.nodeName == "synchSlides")	{
							$(this.children).each(function(k){
								this.setAttribute("overlayPan", "true");

							});
						}
						this.setAttribute("overlayPan", "true");
						this.setAttribute("clearPanel", "true");
					});
				}
				// name and id all other panels
				else{
                    $('<div class="panel" tabindex="0">' + title + '</div>')
                        .appendTo($panelHolder)
                        .attr("id", mediaLesson.panelbaseid + i);
				}
			}
			// layouts where panels are roughly the same size - either in grid or stacked vertically/horizontally
			if ((panelLayout == "tileV" && panelData.length) > 1 || x_browserInfo.mobile == true) {
				$panelHolder.find(".panel").addClass("tileV fullW");

			} else if (panelLayout == "tileH" || panelData.length == 1) {
				$panelHolder.find(".panel").addClass("tileH fullH");
				
			} else if (panelLayout == "grid") {
				if (panelData.length > 2) {
					$panelHolder.append('<div class="top"></div><div class="bottom"></div>');
					
					var panels = $panelHolder.find(".panel");
					
					for (var i=0; i<panels.length; i++) {
						if (i < 2) {
							$(panels[i]).appendTo($panelHolder.find(".top")).addClass("tileH halfH");
						} else {
							$(panels[i]).appendTo($panelHolder.find(".bottom")).addClass("tileH halfH");
						}
					}
					
				} else if (panelData.length > 1) {
				    var $mainHolder = $("#x_mainHolder");
				    // Two panels. If in portrait mode, stack vertical, otherwise show horizontal
					// Use mainHolder, because height of panelHolder is not set on touch/mobile devices
				    if ($mainHolder.width() >= $mainHolder.height() ) {
                        $panelHolder.find(".panel").addClass("tileH fullH");
                    }
                    else
					{
                        $panelHolder.find(".panel").addClass("tileV fullW");
					}
					
				} else {
					$panelHolder.find(".panel").addClass("fullH");
				}
			
			// layouts where screen is split with large panel on one side and smaller panels on other side - can be horizontally or vertically
			} else if (panelLayout == "top" || panelLayout == "bottom") {
				$panelHolder.append('<div class="top"></div><div class="bottom"></div>');
				
				var panels = $panelHolder.find(".panel");
				
				if (panelLayout == "top") {
					for (var i=0; i<panels.length; i++) {
						if (i == 0) {
							$(panels[i]).appendTo($panelHolder.find(".top")).addClass("fullW halfH");
						} else {
							$(panels[i]).appendTo($panelHolder.find(".bottom")).addClass("tileH halfH");
						}
					}
					
				} else if (panelLayout == "bottom") {
					for (var i=0; i<panels.length; i++) {
						if (i == panels.length - 1) {
							$(panels[i]).appendTo($panelHolder.find(".bottom")).addClass("fullW halfH");
						} else {
							$(panels[i]).appendTo($panelHolder.find(".top")).addClass("tileH halfH");
						}
					}
				}
				
			} else {
				$panelHolder.append('<div class="splitScreen"><div class="left"></div><div class="right"></div></div>');
				
				var panels = $panelHolder.find(".panel");
				
				if (panelLayout == "left") {
					for (var i=0; i<panels.length; i++) {
						if (i == 0) {
							$(panels[i]).appendTo($panelHolder.find(".left")).addClass("fullH");
						} else {
							$(panels[i]).appendTo($panelHolder.find(".right")).addClass("tileV");
						}
					}
					
				} else if (panelLayout == "right") {
					for (var i=0; i<panels.length; i++) {
						if (i == panels.length - 1) {
							$(panels[i]).appendTo($panelHolder.find(".right")).addClass("fullH");
						} else {
							$(panels[i]).appendTo($panelHolder.find(".left")).addClass("tileV");
						}
					}
				}
			}
			
			this.resizePanels();
			
			
			// loadMedia & sortPopcorn are called below & also in the media plus plugin which deals with additional media added to panels
			
			// _____ LOAD MEDIA _____
			// Loading media is now handled by the mediaconstructor plugin. (22/12/2021)
		    var mcqBool = true;
		    this.isMCQ = (node) => {
			   var childs = node.childNodes
			   for (var i = 0; i < childs.length; i++) {
				   if (childs[i].nodeName === 'synchMCQ') {
					   mcqBool = false;
				   }
				   this.isMCQ(childs[i]);
			   }
		    }

		    this.isMCQ(x_currentPageXML);

			var mediaPanelData = $(x_currentPageXML).children("mediaPanel");
			if (mediaPanelIndex != -1) {
			    this.popcornInstance = loadMedia(
					$('#' + mediaLesson.panelbaseid + mediaPanelIndex),
					mediaType,
					{	tip: mediaPanelData.attr("tip"),
						width: mediaPanelData.attr("width"),
						height: mediaPanelData.attr("height"),
						media: mediaPanelData.attr("media"),
						autoplay: mediaPanelData.attr("autoplay"),
						aspect: mediaPanelData.attr("aspect"),
						transcript: mediaPanelData.attr("transcript"),
						transcriptBtnTxt: mediaPanelData.attr("transcriptBtnTxt"),
						audioImage: mediaPanelData.attr("audioImage"),
						audioImageTip: mediaPanelData.attr("audioImageTip"),
						pageName: "mediaLesson",
						trackMedia: true,
						doNotCloseTracking: true
					},
					true
					);
			}
			this.resizeMedia()

			//Append the OVERLAY PANEL to the main media.
			for(i = 0; i < panelData.length; i++) {
			    if(panelData[i].nodeName == "overlayPanel") {
                    $('<div class="overlay" id="mydiv"></div>')
						.appendTo($('#' + mediaLesson.panelbaseid + mediaPanelIndex).children(".mainMedia"))
                        .attr("id", mediaLesson.panelbaseid + i)
						.hide();
					$('<div class="overlayGray"></div>')
						.appendTo($('#' + mediaLesson.panelbaseid + mediaPanelIndex).children(".mainMedia"))
                        .attr("id", "overlayGray")
						.css("opacity", "0.75")
						.hide();
                    break;
                }
            }

			$(".panel").each(function(i) {
			    if (i == 0)
					$('<div id="panelContent' + 0 + '" class="panelContent" />').appendTo($(this));
			    else
                    $('<div id="panelContent' + i + '" class="panelContent"/>').appendTo($(this));
			});
			
			// _____ SORT & CREATE SYNCH POINT EVENTS FOR EACH PANEL _____
			if (this.popcornInstance != undefined) {
                panelData.each(function(i) {
                    mediaLesson.sortPopcorn($(this).children(), mediaLesson.panelbaseid + i, mediaLesson.popcornInstance, $(".mainMedia"));
                });
                //Adds events to popcorn
                this.addEvents();
			}
            this.initTracking();

			$('.mainMedia').parents('.panel')
				.addClass('mediaPanel')
				.append('<div id="srInfo" class="sr-only" aria-live="assertive"></div>');
			x_pageLoaded();
		};

		this.addEvents = function() {
            this.popcornInstance.on( "play", function() {
				$("#overlayGray").hide();
            });
        };
		
		// function loads audio in the footer bar (like narration) when it doesn't go in a panel
		this.loadAudioInFooter = function() {
			var $mainAudio = $('<div class="x_pageNarration popcornMedia mainMedia"/>').insertBefore($("#x_footerBlock div:first"));
			 $mainAudio
				.attr("title", $(x_currentPageXML).children("mediaPanel").attr("tip"))
				.mediaPlayer({
					type		:"audio",
					source		:$(x_currentPageXML).children("mediaPanel").attr("media"),
					width       :"100%",
					autoPlay    :$(x_currentPageXML).children("mediaPanel").attr("autoplay")
				});
			return Popcorn(".mainMedia audio");
			x_updateCss(false);
		}
		
		// the following three functions sort synchData (so events have correct start / end points), 
		// creates popcorn instance and calls plugins to create synch points
		// function can be called for mainMedia & additional media from mediaPlus plugin
		this.sortPopcorn = function(synchData, targetRef, popcornInstance, $mediaDiv) {
			// wait until metadata has loaded before continuing
			if (popcornInstance.duration()) {
				mediaLesson.sortPopcornNow(synchData, targetRef, popcornInstance, $mediaDiv);
			} else if (popcornInstance.media._util != undefined && popcornInstance.media._util.type == "Vimeo") {
				function onMessageReceived(event) {
					if (!(/^https?:\/\/player.vimeo.com/).test(event.origin)
					     && !(/^https?:\/\/www.youtube.com/).test(event.origin)) {
						return false;
					}
					
					var data = JSON.parse(event.data);
					if (data.event == "loadProgress") {
						// Vimeo
						$mediaDiv.data("duration", data.data.duration);
						mediaLesson.sortPopcornNow(synchData, targetRef, popcornInstance, $mediaDiv);
						window.removeEventListener("message", onMessageReceived, false);
						// ** vimeo events are unreliable. Sometimes they only start working after play/pause/play again - can't work out why.
						// Possible issue in popcorn.js itself
					}
					if (data.event == "infoDelivery") {
						// YouTube
						//$mediaDiv.data("duration", data.info.duration);
						//mediaLesson.sortPopcornNow(synchData, targetRef, popcornInstance, $mediaDiv);
						//window.removeEventListener("message", onMessageReceived, false);
					}
				}
				window.addEventListener("message", onMessageReceived, false);
			} else if (popcornInstance.media._util != undefined && popcornInstance.media._util.type == "YouTube") {
				function doCallback()
				{
					document.removeEventListener('youtubemetadata', doCallback);
					mediaLesson.sortPopcornNow(synchData, targetRef, popcornInstance, $mediaDiv);
				}
				document.addEventListener('youtubemetadata', doCallback);
			} else {
				popcornInstance.on("loadedmetadata", function() {
					mediaLesson.sortPopcornNow(synchData, targetRef, popcornInstance, $mediaDiv);
				});
			}
		};
		
		// function gets correct synch point - either from absolute value or by converting relative synch points (relative are in format "+5")
		this.sortRelativeSynchPoints = function(type, thisSynch, relativeTo, defaultEnd) {
			var synch;
			if (type == "start") {
				if (thisSynch[0] == "+") {
					// relative start synch is to previous sibling on panel
					synch = $.isNumeric(thisSynch.slice(1)) ? Number(thisSynch.slice(1)) : 0;
					synch += relativeTo;
				} else {
					synch = $.isNumeric(thisSynch) ? Number(thisSynch) : 0;
				}
			} else {
				if (thisSynch != undefined && thisSynch[0] == "+") {
					// relative end synch is to its own start point
					synch = $.isNumeric(thisSynch.slice(1)) ? Number(thisSynch.slice(1)) : defaultEnd;
					synch += relativeTo;
				} else {
					synch = $.isNumeric(thisSynch) ? Number(thisSynch) : defaultEnd;
				}
			}
			return synch;
		};
		
		this.sortPopcornNow = function(synchData, targetRef, popcornInstance, $mediaDiv) {
			var data = new Array(), // array of objects containing details of a synch point event
				prevStart = 0,
				start, end;
            if($(synchData).context.getAttribute("overlay")){
                $(synchData).each(function() {
                    this.overlay = true;
				});
			}
			$(synchData).each(function(j) {
				// ignore the media synchCues as they will be set up separately
				if (this.nodeName != "synchCue") {
					if (this.nodeName != "synchSubtitlePlus") {
						start = mediaLesson.sortRelativeSynchPoints("start", this.getAttribute("synchStart"), prevStart);
						end = mediaLesson.sortRelativeSynchPoints("end", this.getAttribute("synchEnd"), start, undefined);
						prevStart = start;
					} else {
						// there's no start or end synch on subtitle holder - 
						// store previous sibling's start for relative synching to be done against
						start = 0;
					}
					
					data.push({
						type:			this.nodeName,
						start:			start,
						end:			end,
						target:			targetRef + "_" + j,
						optional:		this.getAttribute("optional"),
						allInfo:		this
					});
						
					if ($(this).children().length > 0) {
						if (this.nodeName == "synchMediaPlus") {
							// store child data of media content as they aren't synced to the mainMedia
							data[data.length-1].childNodes = $(this).children();		
						} else {
							var $parent = $(this),
								syncChildren = true,
								prevStartII = prevStart;
							
							this.setAttribute("child", false);
							$parent.children().each(function(k) {
								// if child nodes have a synch point then include their details too
								// with reference to the parent as this will create the holder for the child
								// e.g. for subtitles the parent creates a holder and 1st caption
								// the children then have their own synch points and load in the same holder
								if (this.getAttribute("synchStart") == undefined) {
									syncChildren = false;
								} else {
									// if no end point is set force it to be at the start of the next child
									//otherwise it won't revert if rewinding (if no next child then use parent synchEnd)
									// this won't be right if the next child is using relative synching so it's fixed later after that has been calculated
									var defaultEnd = $parent.children()[k+1] ? $parent.children()[k+1].getAttribute("synchStart") : $.isNumeric($parent[0].getAttribute("synchEnd")) ? ($parent[0].getAttribute("synchEnd")[0] == "+" ? end : Number($parent[0].getAttribute("synchEnd"))) : undefined;
									this.setAttribute("child", true);
									
									var start = mediaLesson.sortRelativeSynchPoints("start", this.getAttribute("synchStart"), prevStartII),
										end = mediaLesson.sortRelativeSynchPoints("end", this.getAttribute("synchEnd"), start, defaultEnd);
									prevStartII = start;
									data.push({
										type:		$(this).parent()[0].nodeName,
										start:		start,
										end:		end,
										target:		targetRef + "_" + j, // ref. to parent synch point to make sure it loads in correct place
										optional:   $(this).parent()[0].optional,
										allInfo:	this
									});
								}
							});
							// store child data if children aren't being synced to media so plugin can use it
							if (syncChildren == false) {
								data[data.length-1].childNodes = $(this).children();
							}
						}
					}
				} else {
					start = mediaLesson.sortRelativeSynchPoints("start", this.getAttribute("synch"), prevStart);
					prevStart = start;
					this.setAttribute("synch", start);
					if (this.getAttribute("destination") != undefined && this.getAttribute("destination")[0] == "+") {
						this.setAttribute("destination", Number(this.getAttribute("destination").slice(1)) + start);
					}
				}
			});

			// fixes any end points that weren't calculated right because of relative synching
			for (var j=0; j<data.length; j++) {
				if (data[j].end != undefined && data[j].end[0] == "+") {
					data[j].end = data[j+1].start;
				}
			}
			
			// sort panel synch events into order (of start synch point)
			data.sort(function (a, b) {
				if (a.start > b.start) {
					return 1;
				}
				if (a.start < b.start) {
					return -1;
				}
				return 0;
			});
			
			// add end points for content already on panel if they are to be removed with "Empty Panel" or because new content clears panel
			for (var j=0; j<data.length; j++) {
				// is content to be cleared?
				if (data[j].type == "synchEmpty" || data[j].allInfo.getAttribute("clearPanel") == "true") {
					var thisStart = data[j].start;
					for (var k=0; k<j; k++) {
						// does previous content need end time added because it's being cleared by next content block?
						if ((data[k].end == undefined || data[k].end > thisStart) && (data[k].type != "synchEmpty" && data[k].type != "synchCue" && data[k].type != "synchSubtitlePlus")) {
							data[k].end = thisStart;
						}
					}
				}
			}
			
			// set end point to end of media if still undefined
			for (var j=0; j<data.length; j++) {
				if (data[j].end == undefined && data[j].type != "synchEmpty" && data[j].type != "synchCue") {
					if (popcornInstance.duration()) {
						data[j].end = popcornInstance.duration() - 0.1;
					} else {
						data[j].end = $mediaDiv.data("duration") - 0.1;
					}
					data[j].autoEnd = true;
				}
			}
			
			// _____ ADD EVENTS FOR EACH SYNCH POINT _____
			// add pause points for mainMedia/mediaPlus
			for (var j=0; j<synchData.length; j++) {
				if (synchData[j].nodeName == "synchCue") {
					mediaLesson.setUpPopcornCue(popcornInstance, synchData[j]);
				}
			}
			// add all other synch events
			for (var j=0; j<data.length; j++) {
				// each synch event
				var thisContent = data[j],
					pluginName = thisContent.type.split("synch")[1].toLowerCase();
				
				// ____ ADD SYNCH EVENT ON SLIDER ____
				
				if (thisContent.type != "synchEmpty") {
					var pluginAttributes = {
						start	  : thisContent.start,
						end		  : thisContent.end,
						target	  : thisContent.target,
						optional  : thisContent.optional,
						overlayPan: thisContent.overlayPanel
					};

					// add other info to pluginAttributes
					$.each(thisContent.allInfo.attributes, function(i, attrib) {
						// ignore attributes that aren't need ed or are dealt with here rather than in individual plugins
						if (attrib.name != "synchStart" && attrib.name != "synchEnd" && attrib.name != "clearPanel" 
								&& attrib.name != "pauseMedia" && attrib.name != "linkID") {
							pluginAttributes[attrib.name] = attrib.value;
						}
					});
					if (thisContent.childNodes) { // used in some plugins e.g. mediaPlus
						pluginAttributes.childNodes = thisContent.childNodes;
					}
					
					// create the holder for the content if it doesn't exist & position it correctly
					var $target = $("#" + targetRef);
					if ($target.find("#" + pluginAttributes.target).length == 0) {
						var $holder;
						var $targetDiv = ($("#" + targetRef + " .panelContent").length > 0 ? $("#" + targetRef + " .panelContent") : $target);
							// ^^ targetDiv is different if it's content to show on top of additional media
						
						if (pluginAttributes.position == "top") {
							$holder = $('<div>').prependTo($targetDiv);
						} else {
							$holder = $('<div>').appendTo($targetDiv);
						}
						
						$holder
							.addClass("contentBlock " + pluginName + "Holder")
							.attr("id", pluginAttributes.target);
					}
					
					if (x_params.authorSupport == "true") {
						var startTxt = x_currentPageXML.getAttribute("supportStart") != undefined ? x_currentPageXML.getAttribute("supportStart") : "start",
							endTxt = x_currentPageXML.getAttribute("supportEnd") != undefined ? x_currentPageXML.getAttribute("supportEnd") : "end",
							authorSupportTxt = thisContent.autoEnd != true ? startTxt + ":" + thisContent.start + " " + endTxt + ":" + thisContent.end : startTxt + ":" + thisContent.start;
						pluginAttributes.name = pluginAttributes.name + ' <span class="alert">[' + authorSupportTxt + ']</span>';
					}
					
					popcornInstance[pluginName](pluginAttributes);
					// ^^ plugins called are either bespoke ones in popcorn/plugins folder or from popcorn-complete.min.js
					// ^^ for those from popcorn-complete.min.js, the xwd node names & values must match the expected popcorn properties for the plugin
					
					if ($.inArray(pluginName, plugins) == -1) {
						// plugin is being called from popcorn-complete.min.js - need to call this too (gets holder in correct state with titles & visibility)
						popcornInstance["sortholder"](pluginAttributes);
					}

					popcornInstance.cue(thisContent.start, function() {
						// pauses media at synch point if needed
						if (thisContent.allInfo.getAttribute("pauseMedia") == "true") {
							this.pause();
							// Gray out the background and fix z-index if the media is paused on an overlay panel
							if (thisContent.allInfo.getAttribute("overlayPan") == "true" && thisContent.type == "synchXot")
							{
							    $("#overlayGray").show();
							}
                            if (thisContent.allInfo.getAttribute("overlay") != "true") {
                                mediaLesson.exitFullScreen();
                            }
						}

						// try to get screen readers to notify user of panel contents change
						if (thisContent.start != 0) {
							const contentChgTxt = x_getLangInfo(x_languageData.find("screenReaderInfo").find("mediaLesson")[0], "prompt") != undefined ? x_getLangInfo(x_languageData.find("screenReaderInfo").find("mediaLesson")[0], "prompt") : (x_params.language === "en-GB" ? "Content added" : undefined);
							if (contentChgTxt !== undefined) {
								$("#srInfo").html(contentChgTxt);
								setTimeout(function() { $("#srInfo").html(''); }, 50);
							}
						}
					});
				}
			}
			x_pageContentsUpdated();
		}

		// function sets up the popcorn sync events for pausing and skipping the media
		// Also shows or hide streams for the mediasite API.
		this.setUpPopcornCue = function(popcornInstance, synchData) {
			popcornInstance.cue(Number(synchData.getAttribute("synch")), function() {
				// pause / play media
				if (synchData.getAttribute("pauseMedia") == "true") { //TODO not here
				    this.pause();
				    if (synchData.getAttribute("overlay") != "true") {
                        mediaLesson.exitFullScreen();
                    }
				} else {
					this.play()
				}

				// Show the following streams (Mediasite)
				// 0: Video 1
				// 1: Document
				// 2: Slides
				// 3: Presentation
				// 4: Video 2
				// 5: Video 3
				if (this.video._util !== undefined && this.video._util.type === "Mediasite")
					if (synchData.getAttribute("visibleStreamTypes") != undefined)
						this.setVST(synchData.getAttribute("visibleStreamTypes"));

				// disable media controls
				if (synchData.getAttribute("disable") == "true") {
					mediaLesson.enableControls(this.media, false);
				}
				
				// skip media
				if (synchData.getAttribute("destination") != undefined && $.isNumeric(synchData.getAttribute("destination"))) {
					this.currentTime(synchData.getAttribute("destination"));
				}
			});
		}
		
		// function disables / enables media controls
		this.enableControls = function(media, enable) {
			if (enable == true) {
				// enable
				if (media.player) {
					media.player.controls = true;
					media.player.controlsEnabled = true;
					media.player.options.clickToPlayPause = true;
					if (media.nodeName == "VIDEO") {
						$(media).parent().parent().find(".mejs-controls").show()
						$(media).parent().parent().find(".mejs-layers").show();
					} else {
						$(media).parent().parent().find(".mejs-controls").children("div").show();
					}
				}
			} else {
				// disable
				if (media.player) {
					media.player.controlsEnabled = false;
					media.player.options.clickToPlayPause = false;
					if (media.nodeName == "VIDEO") {
						$(media).parent().parent().find(".mejs-controls").hide()
						$(media).parent().parent().find(".mejs-layers").hide();
					} else {
						$(media).parent().parent().find(".mejs-controls").children("div").hide();
					}
				}
			}
		}

		// function receives dimensions of video from mediaPlayer.js to set its max dimensions
		this.mediaMetadata = function($video, dimensions) {
			$video.closest(".popcornMedia")
				.css({
					"max-width"	:dimensions[0],
					"max-height":dimensions[1]
				})
				.data({
					"max-width"	:dimensions[0],
					"max-height":dimensions[1]
				});
			
			this.resizeMedia();
		}
	}
	
	mediaLesson.init();
	
</script>


<div id="pageContents">
	
	<div id="infoHolder">
		<h3 class="accTitle"><a href="#"></a></h3>
		<div class="accContent"></div>
	</div>
	
	<div id="contentCover"></div>
	
	<div id="panelHolder"></div>
	
</div>
