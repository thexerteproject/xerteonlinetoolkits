<script type="text/javascript">
/**
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.

 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

	// pageChanged & sizeChanged functions are needed in every model file
	// other functions for model should also be in here to avoid conflicts
	var interactiveText = new function() {
		// vars just used in 1st set up of page
		var tabIndex = '',
			interactionText = "",
			tempTxt = "",
			tempTxtPos = 0,
			tempTag = -1,
			openTagInfo = [];

		// vars that need to be set again on returning to page
		var $pageContents,
			$groupInfo,
			$instructions,
			groupInfo = [],
			subGroups = [],
			currentGroup,
			correctAnswers = [],
			correctOptions = [],
			findAllowSelectionOfAllWords = false;

		this.tickTxt = x_getLangInfo(x_languageData.find("tick")[0], "title") != undefined ? x_getLangInfo(x_languageData.find("tick")[0], "title") : "Correct";
		this.crossTxt = x_getLangInfo(x_languageData.find("cross")[0], "title") != undefined ? x_getLangInfo(x_languageData.find("cross")[0], "title") : "Incorrect";

		// function called every time the page is viewed after it has initially loaded
		this.pageChanged = function() {
			$pageContents = $("#pageContents");
			$groupInfo = $("#groupInfo");
			$instructions = $("#instructions");

			groupInfo = $pageContents.data("groupInfo");
			subGroups = $pageContents.data("subGroups");
			currentGroup = $pageContents.data("currentGroup");
			correctAnswers = $pageContents.data("correctAnswers");
			correctOptions = $pageContents.data("correctOptions");

			findAllowSelectionOfAllWords = false;
			if (x_currentPageXML.getAttribute("interactivity") == "find" || x_currentPageXML.getAttribute("interactivity") == "find2") {
				findAllowSelectionOfAllWords = (x_currentPageXML.getAttribute("findAllowSelectionOfAllWords") != undefined ? x_currentPageXML.getAttribute("findAllowSelectionOfAllWords") === "true" : false);
			}
		};

		this.leavePage = function() {
			$pageContents.data({
				"groupInfo": groupInfo,
				"subGroups": subGroups,
				"currentGroup": currentGroup,
				"correctAnswers": correctAnswers,
				"correctOptions": correctOptions
			});
		};

		this.init = function() {
			$pageContents = $("#pageContents");
			currentGroup = -1;
			$groupInfo = $("#groupInfo");
			$instructions = $("#instructions");

			interactionText = x_addLineBreaks(x_currentPageXML.getAttribute("passage"));

			if (x_currentPageXML.getAttribute("text") != undefined && x_currentPageXML.getAttribute("text") != "") {
				$("#pageTxt").html(x_addLineBreaks(x_currentPageXML.getAttribute("text")));
			} else {
				$("#pageTxt").remove();
			}

			// layout
			if (x_currentPageXML.getAttribute("panelWidth") != "full") { // text to go on left with panel on right
				if (x_browserInfo.mobile != true) {
					$("#passageHolder")
						.addClass("inline")
						.css("float","right");
				} else {
					$("#passageHolder")
						.addClass("mobileInline")
						.insertAfter("#pageTxt");
				}
				if (x_currentPageXML.getAttribute("panelWidth") == "small") {
					$("#passageHolder").addClass("width40");
				} else if (x_currentPageXML.getAttribute("panelWidth") == "large") {
					$("#passageHolder").addClass("width80");
				} else {
					$("#passageHolder").addClass("width60");
				}
			} else { // text above
				$("#passageHolder").insertAfter($instructions);
			}

			var groupStyles = "<style>";
			var illegalDelims = [];

			// get group info
			for (var i=0; i<x_currentPageXML.childNodes.length; i++) {
				if ("&<>;".indexOf(x_currentPageXML.childNodes[i].getAttribute("delimiter")) != -1) {
					illegalDelims.push(x_currentPageXML.childNodes[i].getAttribute("delimiter"));
				} else {
					var group = new Object();
					for (var j=0; j<x_currentPageXML.childNodes[i].attributes.length; j++) {
						group[x_currentPageXML.childNodes[i].attributes[j].name] = x_currentPageXML.childNodes[i].attributes[j].value;
					}
					group.numSubGroups = 0;
					groupInfo.push(group);

					var bgColour = x_getColour(group.bgColour);
					var textDeco = "none";

					groupStyles += " .group" + i + ".on {color:" + x_blackOrWhite(bgColour) + "; background-color:" + bgColour + "; " + "border-radius: 2px ;}";
					if (x_currentPageXML.getAttribute("interactivity") == "find"){
						textDeco = "line-through";
					}

					groupStyles += ".wrongOn" + i + "  {color:" + x_blackOrWhite(bgColour) + "; background-color:" + bgColour + "; " + "text-decoration: " + textDeco + ";" + "border-radius: 2px; padding-top: 5px}";

					if (x_currentPageXML.getAttribute("highlight") == "true") {

						$pageContents.addClass("line");
						groupStyles += " .group" + i + " {border-bottom: 2px solid " + x_getColour(group.bgColour) + ";} ";
					}
				}
			}

			groupStyles += "#pageContents a.listItem:link, #passageHolder a.listItem:visited, #passageHolder a.listItem:hover, #passageHolder a.listItem:active { color: " + $x_body.css("color") + "; } ";
			groupStyles += "</style>";
			$pageContents.prepend($(groupStyles));

			if (illegalDelims.length > 0) {
				var str1 = "",
					str2 = "";
				for (var i=0; i<illegalDelims.length; i++) {
					if (i > 0) {
						if (i != illegalDelims.length - 1) {
							str1 += ", " + illegalDelims[i];
						} else if (i == illegalDelims.length - 1) {
							str2 += illegalDelims[i];
						}
					} else {
						str1 += illegalDelims[i];
					}
				}
				var delimiterErrorMsg = illegalDelims.length > 1 ? (x_currentPageXML.getAttribute("delimiterErrorMsg") != undefined ? x_currentPageXML.getAttribute("delimiterErrorMsg") : "Error: The delimiters {n} and {m} are not allowed.") : (x_currentPageXML.getAttribute("delimiterErrorMsg2") != undefined ? x_currentPageXML.getAttribute("delimiterErrorMsg2") : "Error: The delimiter {n} is not allowed.");
				delimiterErrorMsg = delimiterErrorMsg.replace("{n}", str1).replace("{m}", str2);
				$("#pageContents").prepend('<p class="alert">' + delimiterErrorMsg + '</p>');
			}

			// get info about position of every delimiter in every group - create subgroups from these with an opening & closing delimiter
			for (var i=0; i<groupInfo.length; i++) {
				var temp = interactionText,
					index = 0,
					open = true,
					count = 0;

				if (temp.indexOf(groupInfo[i].delimiter) != -1) {
					while (temp.indexOf(groupInfo[i].delimiter) != -1) {
						var tempIndex = temp.indexOf(groupInfo[i].delimiter);
						index = index + tempIndex;

						if (!(groupInfo[i].delimiter == "#" && temp.indexOf("&#") != -1 && temp.indexOf("&#") + 1 == tempIndex)) { // ignore if fits this as it's likely to be a html code not delimiter
							if (open == true) {
								var subGroup = new Object({
									delim:	groupInfo[i].delimiter,
									open:	index,
									ref:	i,
									overlap:[]
								});
								subGroups.push(subGroup);

								count++;
								open = false;
							} else {
								subGroups[subGroups.length-1].close = index;
								open = true;

							}
						}

						temp = temp.substring(tempIndex + groupInfo[i].delimiter.length);
						index += groupInfo[i].delimiter.length;
					}

					// if the last delimiter isn't closed then ignore it
					if (subGroups[subGroups.length-1].close == undefined) {
						subGroups.pop();
						count--;
					}
				}

				groupInfo[i].numSubGroups = count;
			}

			// distractors are only relevant in the find interactions
			var findUseDistractors = (x_currentPageXML.getAttribute("findUseDistractors") != undefined ? x_currentPageXML.getAttribute("findUseDistractors")==="true" : false);
			if (findUseDistractors && x_currentPageXML.getAttribute("interactivity") == "find" || x_currentPageXML.getAttribute("interactivity") == "find2") {
				var findDistractorDelimiter = (x_currentPageXML.getAttribute("findDistractorDelimiter") != undefined && x_currentPageXML.getAttribute("findDistractorDelimiter").length < 4 ? x_currentPageXML.getAttribute("findDistractorDelimiter") : "");
				if (findDistractorDelimiter != "") {
					var group = new Object();
					group['name'] = '#distractor#';

					group.numSubGroups = 0;
					var temp = interactionText,
							index = 0,
							open = true,
							count = 0;

					if (temp.indexOf(findDistractorDelimiter) != -1) {
						while (temp.indexOf(findDistractorDelimiter) != -1) {
							var tempIndex = temp.indexOf(findDistractorDelimiter);
							index = index + tempIndex;

							if (!(findDistractorDelimiter == "#" && temp.indexOf("&#") != -1 && temp.indexOf("&#") + 1 == tempIndex)) { // ignore if fits this as it's likely to be a html code not delimiter
								if (open == true) {
									var subGroup = new Object({
										delim: findDistractorDelimiter,
										open: index,
										ref: i,
										overlap: []
									});
									subGroups.push(subGroup);

									count++;
									open = false;
								} else {
									subGroups[subGroups.length - 1].close = index;
									open = true;

								}
							}

							temp = temp.substring(tempIndex + findDistractorDelimiter.length);
							index += findDistractorDelimiter.length;
						}

						// if the last delimiter isn't closed then ignore it
						if (subGroups[subGroups.length - 1].close == undefined) {
							subGroups.pop();
							count--;
						}
					}

					group.numSubGroups = count;
					groupInfo.push(group);
				}
			}
			// sort subgroups by opening tag position
			subGroups.sort(function(a, b) { return a.open - b.open; });

			// check for any overlaps within subgroups (because spans can't overlap we will need to add some extra tags in to display them properly)
			for (var i=0; i<subGroups.length; i++) {
				var thisOpen = subGroups[i].open,
					thisClose = subGroups[i].close;

				for (var j=0; j<subGroups.length - (i + 1); j++) { // check against every subsequent subgroups
					var thatOpen = subGroups[j + i + 1].open,
						thatClose = subGroups[j + i + 1].close;

					if (thisOpen < thatOpen && thisClose > thatOpen && thisClose < thatClose) {
						subGroups[i].overlap.push(j + i + 1);
					}
				}
			}

			tabIndex = x_currentPageXML.getAttribute("interactivity") === "explore" ? 'tabindex="0"' : '';
			if (x_currentPageXML.getAttribute("interactivity") == "mcq") {
				$instructions.remove();
			}

			// insert span tags into interactionText
			while (tempTxtPos != interactionText.length) {
				this.createTags();
			}
			interactionText = tempTxt;

			$("#passage").html(interactionText);

			if (x_currentPageXML.getAttribute("interactivity") == "find" || x_currentPageXML.getAttribute("interactivity") == "find2"){
				// Make every regular word a span so that they can be counted as wrong answers
				findAllowSelectionOfAllWords = (x_currentPageXML.getAttribute("findAllowSelectionOfAllWords") != undefined ? x_currentPageXML.getAttribute("findAllowSelectionOfAllWords")==="true" : false);

				if (findAllowSelectionOfAllWords) {
					var passage = $("#passage").children("p");
					for (var p=0; p<passage.length; p++) {
						var passageArray = passage[p].childNodes;
						for (var i = 0; i < passageArray.length; i++) {
							if (passageArray[i].nodeName == "#text") {
								var textArray = passageArray[i].textContent.split(/(\s+)/);
								var newNodeArray = [];
								for (var j = 0; j < textArray.length; j++) {
									if ($.trim(textArray[j]) != '') {
										var newNode = document.createElement('SPAN');
										newNode.innerHTML = textArray[j];
										newNode.className += 'wrongWord';
										newNodeArray.push(newNode);
									} else {
										var newNode = document.createTextNode(textArray[j]);
										newNodeArray.push(newNode);
									}
								}
								for (var k = 0; k < newNodeArray.length; k++) {
									passage[p].insertBefore(newNodeArray[k], passageArray[i + k])
								}
								i += newNodeArray.length;
								passageArray[i].remove();
							}
						}
					}
				}

				correctOptions = [];
				correctAnswers = [];
				var index = 0;
				$("#passage span").each(function(){
					var span = $(this);
					span.attr("data-index", index);

					if (span.hasClass("group")){
						var groupNumber = parseInt(span.attr("class")[span.attr("class").length - 1]);
						if (correctOptions[groupNumber] === undefined){
							correctAnswers[groupNumber] = [];
							correctOptions[groupNumber] = [];
						}

						correctOptions[groupNumber].push(
							{
								id: span.attr("data-index"),
								answer: span.text(),
								result: true
							}
						);
						correctAnswers[groupNumber].push(span.text() + "<br>");
					}
					index++;
				});

				if (x_currentPageXML.getAttribute("interactivity") == "find2"){
					// Track the page
					this.weighting = 1.0;
					if (x_currentPageXML.getAttribute("trackingWeight") != undefined){
						this.weighting = x_currentPageXML.getAttribute("trackingWeight");
					}
          			XTSetPageType(x_currentPage, 'numeric', groupInfo.filter(gi => gi.name !== '#distractor#').length, this.weighting);
				}
			}

			this.setUpInteraction();

			x_pageLoaded();
		};

		this.createTags = function() {
			if (openTagInfo.length == 0) { // there are no tags currently open...
				if (subGroups.length - 1 == tempTag) { // ...no more tags to add
					tempTxt += interactionText.substring(tempTxtPos);
					tempTxtPos = interactionText.length;

				} else { // ...insert next tag
					this.openTag();
				}

			} else { // there are some tags already open...
				var toClose = openTagInfo[0];
				for (var i=0; i<openTagInfo.length-1; i++) {
					toClose = subGroups[openTagInfo[i+1]].close < subGroups[toClose].close ? openTagInfo[i+1] : toClose;
				}

				if (subGroups.length - 1 == tempTag || subGroups[toClose].close < subGroups[tempTag + 1].open) { // ...close a tag (ensuring no overlapping tags)
					tempTxt += interactionText.substring(tempTxtPos, subGroups[toClose].close);
					for (var j=0; j<subGroups[toClose].overlap.length; j++) {
						tempTxt += '</span>';
					}
					tempTxt += '</span>';
					tempTxtPos = subGroups[toClose].close + subGroups[toClose].delim.length;
					for (var j=0; j<subGroups[toClose].overlap.length; j++) {
						tempTxt += '<span class="group group' + subGroups[subGroups[toClose].overlap[j]].ref + '" data-index="' + subGroups[toClose].overlap[j] + '" ' + tabIndex + '>';
					}
					openTagInfo = jQuery.grep(openTagInfo, function(value) {
						return value != toClose;
					});

				} else { //...open another tag
					this.openTag();
				}
			}
		};

		this.openTag = function() {
			tempTag++;
			tempTxt += interactionText.substring(tempTxtPos, subGroups[tempTag].open);
			tempTxt += '<span class="group group' + subGroups[tempTag].ref + '" data-index="' + tempTag + '" ' + tabIndex + '>';
			tempTxtPos = subGroups[tempTag].open + subGroups[tempTag].delim.length;
			openTagInfo.push(tempTag);
		};

		this.setUpInteraction = function() {
			var intType = x_currentPageXML.getAttribute("interactivity");
			$pageContents.addClass(intType);
			// --- EXPLORE ---
			// click any subgroup - you then get info about the group it falls into, with the option of showing all related subgroups
			if (intType == "explore") {
				$('<button id="showBtn"></button>')
					.appendTo("#btnHolder")
					.hide();
				var instructions = x_currentPageXML.getAttribute("exploreTxt") != undefined ? x_currentPageXML.getAttribute("exploreTxt") : "Explore the text. Click on a section to learn more.";
				$instructions.html('<p>' + instructions + '</p>');

                $("#questionHolder").hide();

				$("#passage").click(function(e) {
					var $this = $(this);
					$this.find(".group")
						.removeClass("on")
						.removeAttr("role")
						.find(".sr-only").remove();

					if ($(e.target).hasClass("group")) {
						var clicked = $.merge($(e.target), $(e.target).parents(".group"));
						interactiveText.clickExplore($(clicked[0]));

					} else {
						currentGroup = -1;
						$groupInfo.html("");
						$("#showBtn").hide();
					}
				});

				$("#passage .group")
					.focusin(function() { $(this).addClass("highlight"); })
					.focusout(function() { $(this).removeClass("highlight"); })
					.keypress(function(e) {
						var charCode = e.charCode || e.keyCode;
						if (charCode == 32) {
							$("#passage").find(".group")
								.removeClass("on")
								.removeAttr("role")
								.find(".sr-only").remove();

							interactiveText.clickExplore($(this));
						}
					});

				$("#showBtn")
					.button({
						label:	(x_currentPageXML.getAttribute("showBtnTxt") != undefined ? x_currentPageXML.getAttribute("showBtnTxt") : "Show All")
					}).click(function() {
						var plainGrpName = $('<p>' + groupInfo[currentGroup].name + '</p>').text();
						$("#passage .group" + currentGroup + ":not(.on)")
							.addClass("on")
							.attr("role", "mark")
							.prepend("<span class='sr-only'>" + plainGrpName + ": </span>");

						$(this).hide();
					});


			// --- SHOW ME (BY NAME) ---
			// group names are shown and subgroups are highlighted when a group is selected
			} else if (intType == "show") {
				$("#questionHolder").hide();
				$instructions.html('<p>' + (x_currentPageXML.getAttribute("showMeTxt2") != undefined ? x_currentPageXML.getAttribute("showMeTxt2") : "Click a group to learn more.") + '</p>');

				$("#btnHolder").remove();
				const $btnHolder = $('<ul id="btnHolder"></ul>').insertBefore($("#passage"));

				for (var i=0; i<groupInfo.length; i++) {
					var $groupBtn = $('<a/>');
					$groupBtn
						.addClass("listItem")
						.html(groupInfo[i].name)
						.attr({"href": "#"})
						.data("index", i);

					const $li = $("<li></li>").append($groupBtn);
					$btnHolder.append($li);
				}

				$btnHolder.find(".listItem")
					.click(function(e) {
						e.preventDefault();

						var index = $(this).data("index");

						if (currentGroup != index) {
							$("#btnHolder .listItem.highlight")
									.removeClass("highlight")
									.parent().removeAttr("aria-current");

							$("#passage .group")
								.removeClass("on")
								.removeAttr("role")
								.find(".sr-only").remove();

							$(this)
								.addClass("highlight")
								.parent().attr("aria-current", "true");

							var plainGrpName = $('<p>' + groupInfo[index].name + '</p>').text();
							$("#passage .group" + index)
								.addClass("on")
								.attr("role", "mark");

							$groupInfo
								.hide()
								.html('<h3>' + groupInfo[index].name + '</h3>' + x_addLineBreaks(groupInfo[index].text))
								.fadeIn();

							currentGroup = index;
							x_pageContentsUpdated();
						}
					});


			// --- SHOW ME (IN ORDER) ---
			// next/prev buttons show details of each group in turn, highlighting relevant subgroups
			} else if (intType == "show2") {
				$("#questionHolder").hide();
				$instructions.html('<p>' + (x_currentPageXML.getAttribute("showMeTxt") != undefined ? x_currentPageXML.getAttribute("showMeTxt") : "Click the arrow buttons to learn more.") + '</p>');
				$("#btnHolder")
					.html('<button id="prevBtn"></button><button id="nextBtn"></button>')
					.insertAfter($("#passage"));

				var btnTxt = [
					x_currentPageXML.getAttribute("nextTxt") != undefined ? x_currentPageXML.getAttribute("nextTxt") : "Next",
					x_currentPageXML.getAttribute("prevTxt") != undefined ? x_currentPageXML.getAttribute("prevTxt") : "Previous"
				];

				$("#nextBtn")
					.button({
						icons: {
							primary: "fa fa-x-next"
						},
						label:	btnTxt[0],
						text:	false,
						disabled:	(groupInfo.length == 0)
					})
					.click(function() {
						currentGroup++;

						$("#passage .group")
							.removeClass("on")
							.removeAttr("role")
							.find(".sr-only").remove();

						var plainGrpName = $('<p>' + groupInfo[currentGroup].name + '</p>').text();
						$("#passage .group" + currentGroup)
							.addClass("on")
							.attr("role", "mark")
							.prepend("<span class='sr-only'>" + plainGrpName + ": </span>");

						$groupInfo
							.hide()
							.html('<h3>' + groupInfo[currentGroup].name + '</h3>' + x_addLineBreaks(groupInfo[currentGroup].text))
							.fadeIn();

						if (currentGroup == groupInfo.length - 1) {
							$(this).button("disable");
						}
						$("#prevBtn").button("enable");

						x_pageContentsUpdated();
					});

				$("#prevBtn")
					.button({
						icons: {
							primary: "fa fa-x-prev"
						},
						label:	btnTxt[1],
						text:	false,
						disabled:	true
					})
					.click(function() {
						currentGroup--;
						$("#passage .group")
							.removeClass("on")
							.removeAttr("role")
							.find(".sr-only").remove();

						if (currentGroup == -1) {
							$(this).button("disable");
							$groupInfo.html("");
						} else {
							var plainGrpName = $('<p>' + groupInfo[currentGroup].name + '</p>').text();
							$("#passage .group" + currentGroup)
								.addClass("on")
								.attr("role", "mark")
								.prepend("<span class='sr-only'>" + plainGrpName + ": </span>");

							$groupInfo
								.hide()
								.html('<h3>' + groupInfo[currentGroup].name + '</h3>' + x_addLineBreaks(groupInfo[currentGroup].text))
								.fadeIn();
						}
						$("#nextBtn").button("enable");

						x_pageContentsUpdated();
					});


			// --- FIND ---
			// select a group and then click to find all of its subgroups
			} else if (intType == "find" || intType=="find2") {
				if (intType == "find"){
					$pageContents.data({
						"found" : [],
						"wrongFound": [],
						"complete" : [],
						"findTxt2" : x_currentPageXML.getAttribute("findTxt2") != undefined ? x_currentPageXML.getAttribute("findTxt2") : "You have found {i} of {n}"
					});
				}else{
					$pageContents.data({
						"found" : [],
						"wrongFound": [],
						"complete" : [],
						"findTxt2" : x_currentPageXML.getAttribute("findTxt22") != undefined ? x_currentPageXML.getAttribute("findTxt22") : "You have selected {i} of {n}"
					});
				}

				var $btnHolder = $("#btnHolder");
				$btnHolder.insertBefore($("#passage"));
				$("#questionHolder").hide();

				var count = this.setUpFind(true);

				$("#feedback").insertAfter($("#passage"));

				//If the type is Find(Mark at End), add a button to let the user finish up
				if (intType=="find2"){
					$("<div id='buttonHolder'><button disabled id='markAtEnd'>Check</button></div>").insertBefore($("#feedback"));
					var markAtEndLabel = x_currentPageXML.getAttribute("findCheckTxt") != undefined ? x_currentPageXML.getAttribute("findCheckTxt") : "Check";
					$("#markAtEnd").button({
						label:	markAtEndLabel,
						disabled:	true
					});
				}

				// there's only one group marked up - no need for listItems
				if (count == 1) {
					// add tab index to groups in passage immediately
					$("#passageHolder:not(.disabled) #passage .group").attr("tabindex", "0");

					currentGroup = $("#btnHolder .listItem").data("index");
					$("#btnHolder .listItem").remove();
					$instructions.html('<p>' + (x_currentPageXML.getAttribute("findTxt3") != undefined ? x_currentPageXML.getAttribute("findTxt3") : "Can you find all of the examples?") + '</p>');

					$groupInfo
						.hide()
						.html('<h3>' + groupInfo[currentGroup].name + '</h3>' + x_addLineBreaks(groupInfo[currentGroup].text))
						.fadeIn();

					if (intType == "find"){
						$("#feedback")
							.html('<p>' + $pageContents.data("findTxt2")
								.replace("{i}", $pageContents.data("found")[currentGroup].length)
								.replace("{n}", groupInfo[currentGroup].numSubGroups) + '</p>')
							.show();
					} else if (intType == "find2" && x_currentPageXML.getAttribute("findShowNum") !== "false"){
						$("#feedback")
							.html('<p>' + $pageContents.data("findTxt2")
								.replace("{i}", $pageContents.data("found")[currentGroup].length + $pageContents.data("wrongFound")[currentGroup].length)
								.replace("{n}", groupInfo[currentGroup].numSubGroups) + '</p>')
							.show();
					}
				} else {
					$instructions.html('<p>' + (x_currentPageXML.getAttribute("findTxt") != undefined ? x_currentPageXML.getAttribute("findTxt") : "Click a group to begin, then click the text to find all examples.") + '</p>');
				}

				$("#btnHolder .listItem").click(function(e) {
					e.preventDefault();

					var index = $(this).data("index");
					if (currentGroup != index) {
						currentGroup = index;
						$("#btnHolder .listItem.highlight")
							.removeClass("highlight")
							.parent().removeAttr("aria-current");

						$(this)
							.addClass("highlight")
							.parent().attr("aria-current", true);

						$groupInfo
							.hide()
							.html('<h3>' + groupInfo[index].name + '</h3>' + x_addLineBreaks(groupInfo[index].text))
							.fadeIn();

						if ($.inArray(0, $pageContents.data("complete")) != -1) {
							if (intType == "find"){
								$("#feedback")
									.html('<p>' + $pageContents.data("findTxt2")
										.replace("{i}", $pageContents.data("found")[currentGroup].length)
										.replace("{n}", groupInfo[currentGroup].numSubGroups) + '</p>')
									.show();
							} else if (intType == "find2" && x_currentPageXML.getAttribute("findShowNum") !== "false"){
								$("#feedback")
									.html('<p>' + $pageContents.data("findTxt2")
										.replace("{i}", $pageContents.data("found")[currentGroup].length + $pageContents.data("wrongFound")[currentGroup].length)
										.replace("{n}", groupInfo[currentGroup].numSubGroups) + '</p>')
									.show();
							}
						}

						// remove all highlights
						$("#passage .group")
							.removeClass("on")
							.removeAttr("role")
							.find(".sr-only").remove();

						for (var group = 0; group < groupInfo.length; group++){
							$("#passage span").removeClass("wrongOn" + group);
						}

						// add correct highlights for this group
						for (var i=0; i<$pageContents.data("found")[index].length; i++) {
							$("#passage .group" + currentGroup + "[data-index=" + $pageContents.data("found")[index][i] + "]")
								.addClass("on")
								.attr("role", "mark");
						}

						for (var i=0; i<$pageContents.data("wrongFound")[index].length; i++) {
							$(".wrongGroup"+  currentGroup + "[data-index=" + $pageContents.data("wrongFound")[index][i] + "]").addClass("wrongOn" + currentGroup);

							if (intType == "find" || $("#markAtEnd").is(":hidden")) {
								// if answer is marked incorrect immediately, change sr-only text to reflect this
								var incorrectAnswerTxt = (x_currentPageXML.getAttribute('incorrectAnswerTxt') != undefined ? x_currentPageXML.getAttribute('incorrectAnswerTxt') : "Incorrect Answer");
								$(".wrongGroup"+  currentGroup + "[data-index=" + $pageContents.data("wrongFound")[index][i] + "]")
									.attr("role", "mark")
									.prepend("<span class='sr-only'>" + incorrectAnswerTxt + ": </span>");
							} else {
								// otherwise, just confirm it's selected
								$(".wrongGroup"+  currentGroup + "[data-index=" + $pageContents.data("wrongFound")[index][i] + "]").attr("role", "mark");
							}
						}

						// add tab index to groups in passage only after a group is selected & if max no. selections haven't been made
						if (!checkComplete(x_currentPageXML.getAttribute("interactivity"), currentGroup)) {
							$("#passageHolder:not(.disabled) #passage .group").attr("tabindex", "0");

						} else if (!$("#passageHolder").hasClass("disabled")) {
							$("#passage .group.on, #passage .group.wrongOn" + currentGroup).attr("tabindex", "0");
							$("#passage .group:not(.on, .wrongOn" + currentGroup + ")").removeAttr("tabindex");
						}
					}
				});

				$("#passage").click(function(e) {
					interactiveText.clickFind($(e.target), currentGroup)
				});

				$("#passage .group").keypress(function(e) {
					var charCode = e.charCode || e.keyCode;
					if (charCode == 32) {
						interactiveText.clickFind($(this), currentGroup);
					}
				});

				$("#markAtEnd").click(function () { interactiveText.endFindInteraction(); $("#markAtEnd").hide();});

			// --- MCQ ---
			// quiz asks what is highlighted
			} else if (intType == "mcq") {

				// set up dialog object for later if it hasn't already been set up on another page of this type
				// xenith.js contains the function used for creating/attaching dialogs - x_openDialog()
				var newDialog = true;
				$(x_dialogInfo).each(function(i) {
					if (this.type == "interactiveText") {
						newDialog = false;
					}
				});
				if (newDialog == true) {
					var dialog = new Object();
					dialog.type = "interactiveText";
					dialog.built = false;
					x_dialogInfo.push(dialog);
				}

				// get all fixed strings used in quiz
				var phrases = {},
					langOptions = ["mcqText", "mcqQuesCount", "mcqCorrect", "mcqWrong", "mcqFeedback", "mcqMore", "mcqScore", "mcqBtnTxt", "mcqBtnTxt2", "mcqBtnTxt3"],
					defaultText = ["What is highlighted in the text? Choose from the following options:", "Question {i} of {n}", "That's right.", "No, the correct answer is {i}.", "You have completed the quiz.", "More Information", "You scored {i} / {n}", "Check", "Next", "Restart"];

				for (var i=0; i<langOptions.length; i++) {
					phrases[langOptions[i]] = x_currentPageXML.getAttribute(langOptions[i]) != undefined ? x_currentPageXML.getAttribute(langOptions[i]) : defaultText[i];
				}
				$pageContents.data("phrases", phrases);


				$("#questionHolder").html('<p id="qNum" ' + '" aria-live="polite"></p><div id="qText"><p>' + phrases.mcqText + '</p></div><div id="optionHolder"></div>');

				var moreInfoIcon = x_currentPageXML.getAttribute("mcqMoreInfo") !== "false" ? '<p class="fb"><a id="more" class="fa fa-x-info-circle fa-lg" title="' + phrases.mcqMore + '" href="#"><span class="sr-only">' + x_getLangInfo(x_languageData.find("screenReaderInfo")[0], "dialog", "") + '</span></a></p>' : '';

				$("#feedback")
					.html('<div id="marking"><span id="fb" aria-live="polite"></span>' + moreInfoIcon + '</div>')
					.appendTo($("#questionHolder"))
					.removeAttr("aria-live")
					.find("#more")
						.click(function(e) {
							e.preventDefault();
							correctGroup = x_currentPageXML.getAttribute("mcqType") == "all" ? $pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")] : subGroups[$pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")]].ref;
							x_openDialog("interactiveText", groupInfo[correctGroup].name, x_getLangInfo(x_languageData.find("closeBtnLabel")[0], "label", "Close"), {left:"center", top:"middle", width:undefined, height:undefined}, x_addLineBreaks(groupInfo[correctGroup].text));
						})
						.hide();

				$("#btnHolder")
					.html('<button id="quizBtn"></button>')
					.appendTo($("#questionHolder"))
					.after($groupInfo);

				$("#quizBtn")
					.button()
					.click(function() {
						var correct,
							l_options = [],
							l_answer = [],
							l_feedback = [];

						$(".x_popupDialog").parent().detach();

						if ($(this).data("state") == 0) { // check
							var correctGroup = x_currentPageXML.getAttribute("mcqType") == "all" ? $pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")] : subGroups[$pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")]].ref;
							l_answer.push($pageContents.data("mcqAnswerOptions")[$("#optionHolder input:checked").val()]['text']);
							l_feedback.push($("#fb").text().trim());

							$("#optionHolder input").prop('disabled', true);

							if (correctGroup == $("#optionHolder input:checked").val()) {
								$("#fb").html('<p class="fb">' + $pageContents.data("phrases").mcqCorrect + '</p>');
								$pageContents.data("mcqScore", $pageContents.data("mcqScore")+1);
								correct = true;
							} else {
								$("#fb").html('<p class="fb">' + $pageContents.data("phrases").mcqWrong.replace("{i}", groupInfo[correctGroup].name) + '</p>');
								correct = false;
							}

							l_options.push({
								id: parseInt($("#optionHolder input:checked").val()) + 1 + "",
								answer: $pageContents.data("mcqAnswerOptions")[$("#optionHolder input:checked").val()]['text'],
								result: correct
							});

							if ($("<div/>").html(groupInfo[correctGroup].text).text().trim() != "") {
								$("#more").show();
							} else {
								$("#more").hide();
							}

							var result = {
								success: correct,
								score: correct ? 100.0 : 0.0
							};
							XTExitInteraction(x_currentPage, $pageContents.data("mcqCurrentQ"), result, l_options, l_answer, l_feedback, x_currentPageXML.getAttribute("trackinglabel"));

							$(this)
								.button({"label":$pageContents.data("phrases").mcqBtnTxt2})
								.data("state", 1);

						} else if ($(this).data("state") == 1) { // next
							if ($pageContents.data("mcqCurrentQ") + 1 == $pageContents.data("mcqAnswers").length) {
								$("#passage .group")
									.removeClass("on")
									.removeAttr("role");

								$("#qText").hide();
								$("#optionHolder").hide();

								$("#fb").html('<p>' + $pageContents.data("phrases").mcqScore.replace("{i}", $pageContents.data("mcqScore")).replace("{n}", $pageContents.data("mcqAnswers").length) + '</p>' + (x_currentPageXML.getAttribute("mcqFB") != "" && x_currentPageXML.getAttribute("mcqFB") != undefined ? x_currentPageXML.getAttribute("mcqFB") : ""));
								$("#more").hide();

								$("#qNum").html($pageContents.data("phrases").mcqFeedback);

								if (XTGetMode() == "normal")
								{
									$(this)
										.button("disable").hide()
										.data("state", 2);
								}
								else {
									$(this)
										.button({"label": $pageContents.data("phrases").mcqBtnTxt3})
										.data("state", 2);
								}

								interactiveText.finishTracking();

							} else {
								interactiveText.createQ();
							}
						} else if (XTGetMode() != "normal") { // restart
							interactiveText.createQuiz();
						}
					});
				this.createQuiz();
			}
		};

		// only used in explore interaction - triggered when subgroup selected (with or without mouse)
		this.clickExplore = function($this) {
			var index = $this.data("index"),
				prevGroup = currentGroup;

			currentGroup = subGroups[index].ref;

			var plainGrpName = $('<p>' + groupInfo[currentGroup].name + '</p>').text();
			$("#passage").find(".group[data-index='" + index + "']")
				.addClass("on")
				.attr("role", "mark")
				.prepend("<span class='sr-only'>" + plainGrpName + ": </span>");

			$("#passage .group").removeClass("highlight");

			if (prevGroup != currentGroup) {
				$groupInfo
					.hide()
					.html('<h3>' + groupInfo[currentGroup].name + '</h3>' + x_addLineBreaks(groupInfo[currentGroup].text))
					.fadeIn();

				$("#showBtn").hide();
			}

			// button offers option of viewing all related subgroups
			if ($("#passage").find(".group" + currentGroup).length > 1) {
				$("#showBtn").fadeIn();
			} else {
				$("#showBtn").hide();
			}

			x_pageContentsUpdated();
		};

		// only used in find interactions - sets up arrays to hold found/complete data & create buttons
		this.setUpFind = function(firstLoad) {
			var count = 0;
			$("#btnHolder").remove();
			const $btnHolder = $('<ul id="btnHolder"></ul>').insertBefore($("#passage"));

			for (var i=0; i<groupInfo.length; i++) {
				if(firstLoad){
					$pageContents.data("found").push([]);
					$pageContents.data("wrongFound").push([]);
				}
				if (groupInfo[i].numSubGroups > 0 && groupInfo[i].name != "#distractor#") {
					if (firstLoad == true) {
						var $groupBtn = $('<a/>');
						$groupBtn
							.addClass("listItem")
							.html(groupInfo[i].name)
							.attr({"href": "#"})
							.data("index", i);

						const $li = $("<li></li>").append($groupBtn);
						$btnHolder.append($li);
					}

					count++;
					$pageContents.data("complete").push(0);
				} else {
					$pageContents.data("complete").push(1);
				}
			}
			return count;
		};

		// only used in find interaction - triggered when subgroup selected (with or without mouse)
		this.clickFind = function($this, currentGroup) {
			if ($("#passageHolder").hasClass("disabled"))
				return;

			var intType = x_currentPageXML.getAttribute("interactivity");
			if (currentGroup != -1) { // If no group is selected, do nothing.
				// If the user wants to undo their choice:
				if ($this.hasClass("on")){
					$this
						.removeClass("on")
						.removeAttr("role")
						.find(".sr-only").remove();
					var arr = $pageContents.data("found")[currentGroup];
					arr.splice(arr.indexOf($this.data("index")), 1);
				} else if ($this.hasClass("wrongOn" + currentGroup)){
					$this
						.removeClass("wrongOn" + currentGroup + " wrongGroup" + currentGroup)
						.removeAttr("role")
						.find(".sr-only").remove();
					var arr = $pageContents.data("wrongFound")[currentGroup];
					arr.splice(arr.indexOf($this.data("index")), 1);
				}
				// if the clicked word is a "wrongWord" count it as wrong.
				else if ($this.hasClass('wrongWord') && !$this.hasClass('group') && findAllowSelectionOfAllWords){
					markWrong($this, intType, currentGroup);

				} else if ($this.hasClass('group')){
					var clicked = $.merge($this, $this.parents(".group"));
					var wrong = true;
					if (!checkComplete(intType, currentGroup)){
						for (var i=0; i<clicked.length; i++) {
							if ($(clicked[i]).hasClass("group" + currentGroup)) {
								wrong = false;

								if(!$(clicked[i]).hasClass('on')){
									$(clicked[i])
										.addClass("on")
										.attr("role", "mark");

									//Add found (correct) answer to the found array
									$pageContents.data("found")[currentGroup].push($(clicked[i]).data("index"));
								}

								break; // break out of loop when one correct answer is found, no need to check further parents, this would only result in false negatives

							} else if (!$(clicked[i]).hasClass("on") && !$(clicked[i]).hasClass("wrongOn" + currentGroup)) {
								$(clicked[i])
									.removeAttr("role")
									.find(".sr-only").remove();
							}
						}
					}
					// if a grouped word was clicked, but it and its parents belong to the wrong group, count it as wrong.
					if (wrong && !$this.hasClass('wrongWord')){
						markWrong($this, intType, currentGroup);
					}
				}

				if (intType == "find"){
					$("#feedback")
								.html('<p>' + $pageContents.data("findTxt2")
								.replace("{i}", $pageContents.data("found")[currentGroup].length)
								.replace("{n}", groupInfo[currentGroup].numSubGroups) + '</p>')
								.show();

					// If all answers in this groups are found:
					if ($pageContents.data("found")[currentGroup].length == groupInfo[currentGroup].numSubGroups) {
						// Put a 1 in the complete array on the index of this group
						$pageContents.data("complete").splice(currentGroup, 1, 1);
						// If there are no more 0's in the "complete array" (aka everything is complete)
						if ($.inArray(0, $pageContents.data("complete")) == -1) {
                            finalFeedback($pageContents.data("wrongFound"));
						}
					}
				} else if (intType == "find2"){
					if (x_currentPageXML.getAttribute("findShowNum") !== "false") {
						$("#feedback")
							.html('<p>' + $pageContents.data("findTxt2")
								.replace("{i}", $pageContents.data("found")[currentGroup].length + $pageContents.data("wrongFound")[currentGroup].length)
								.replace("{n}", groupInfo[currentGroup].numSubGroups) + '</p>')
							.show();

						// If there are as many selections made as there are right answers to be found in this group:
						if ($pageContents.data("found")[currentGroup].length + $pageContents.data("wrongFound")[currentGroup].length == groupInfo[currentGroup].numSubGroups) {
							// Put a 1 in the complete array on the index of this group:
							$pageContents.data("complete").splice(currentGroup, 1, 1);
							// If there are no more 0's in the "complete array" (aka everything is complete)
							if ($.inArray(0, $pageContents.data("complete")) == -1) {
								$("#feedback").html('<p>' + (x_currentPageXML.getAttribute("find2Feedback") != undefined ? x_currentPageXML.getAttribute("find2Feedback") : "You have selected the the correct number of items, please click the button to check your answers.") + '</p>');
								$("#markAtEnd").button("enable");
							}
						} else {
							// Make sure it's a 0 in the complete array on the index of this group (might have been 0 is last click was to deselect an item):
							$pageContents.data("complete").splice(currentGroup, 1, 0);
							$("#markAtEnd").button("disable");
						}

					} else {
						// there is no restriction on no. of selections in each group (as long as at least 1 selection has been made)
						if ($pageContents.data("found")[currentGroup].length + $pageContents.data("wrongFound")[currentGroup].length > 0) {
							// Put a 1 in the complete array on the index of this group:
							$pageContents.data("complete").splice(currentGroup, 1, 1);
							// If there are no more 0's in the "complete array" (aka everything is complete)
							if ($.inArray(0, $pageContents.data("complete")) == -1) {
								$("#markAtEnd").button("enable");
							}

						} else {
							// Make sure it's a 0 in the complete array on the index of this group (might have been 0 is last click was to deselect an item):
							$pageContents.data("complete").splice(currentGroup, 1, 0);
							$("#markAtEnd").button("disable");
						}
					}
				}
				// remove tab index from unselected groups when the max has been reached
				if (checkComplete(intType, currentGroup)) {
					$("#passage .group:not(.on, .wrongOn" + currentGroup + ")").removeAttr("tabindex");
				} else {
					$("#passage .group").attr("tabindex", "0");
				}
			}
		};

		/*
			To end the find2 interaction, we cheat a bit and use a multiple choice interaction. We already know the correct answers since the beginning, but we can add the
			wrong answers the user chose as false options.
		 	the order of chosen answers does not matter, because the result score is based on the amount of correctFound answers.
			However, how it results.html / xttracking_noop.js work right now, you cannot have 2 same answers where 1 is wrong
			this situation would happen if the answer depended on the context ("select the instances where 'trip' is used as a verb, not a noun")
			We can see the difference now because we include the "data-index" in the answer, but for a user this is unintuitive and we need to find a better solution, or forbid it.
			if the answers on the results page are checked by their options data instead of their answers data,
			we could see the difference between a right and wrong answer that is the same word
		*/
		this.endFindInteraction = function() {
			var correctFound = $pageContents.data("found");
			var incorrectFound = $pageContents.data("wrongFound");
			var endScore = 0;
			var l_options = [];
			var l_answers = [];
			for (var group = 0; group < correctFound.length; group++){
				if (groupInfo[group].name == "#distractor#")
				{
					continue;
				}
				l_options[group] = [];
				l_answers[group] = [];

				var groupName = groupInfo[group].name;

				for (var i = 0; i < correctFound[group].length; i++){
					var span = $('*[data-index=' + correctFound[group][i]+ ']');
					const $temp = span.clone();
					$temp
						.removeAttr("role")
						.find(".sr-only").remove();
					l_options[group].push(
						{
							id: span.attr("data-index"),
							answer: $temp.text(),
							result: true
						}
					);
					l_answers[group].push($temp.text() + "<br>");
				}

				var percentageCorrect = 0;
				if (correctOptions[group].length != 0)
					percentageCorrect = correctFound[group].length / correctOptions[group].length * 100;

				endScore += (correctFound[group].length == correctOptions[group].length ? 1 : 0);

				for (var i = 0; i < incorrectFound[group].length; i++){
					var span = $('*[data-index=' + incorrectFound[group][i]+ ']')
					const $temp = span.clone();
					$temp
						.removeAttr("role")
						.find(".sr-only").remove();
					wrongOption =
						{
							id: span.attr("data-index"),
							answer: $temp.text(),
							result: false
						}
					l_options[group].push(wrongOption);
					correctOptions[group].push(wrongOption);
					l_answers[group].push($temp.text() + "<br>");
				}

				var correct = percentageCorrect == 100;
				var result = {
								success: correct,
								score: (correct ? 100 : 0)
							};
				XTEnterInteraction(x_currentPage, group, 'multiplechoice', groupName, correctOptions[group], correctAnswers[group], [], x_currentPageXML.getAttribute("grouping"));
				XTExitInteraction(x_currentPage, group, result, l_options[group], l_answers[group], []);
			}
			showAnswers(l_answers, l_options);
			var total = 0;
			for (var group = 0; group < correctFound.length; group++) {
				if (groupInfo[group].name == "#distractor#") {
					continue;
				}
				total++;
			}
			var score = endScore / total * 100;
			XTSetPageScore(x_currentPage, score);
			$("#passageHolder").addClass("disabled");
			$("#passageHolder .group").removeAttr("tabindex");
		};

		//Mark a wrong word as wrong in the find2 interaction
		function markWrong(target, intType, currentGroup){
			if (checkComplete(intType, currentGroup)){
				return;
			}
			if (!$(target).hasClass("wrongGroup" + currentGroup + " wrongOn" + currentGroup)){
				$(target).addClass("wrongGroup" + currentGroup + " wrongOn" + currentGroup);

				if (intType == "find") {
					// if answer is marked incorrect immediately, add sr-only text to reflect this
					var incorrectAnswerTxt = (x_currentPageXML.getAttribute('incorrectAnswerTxt') != undefined ? x_currentPageXML.getAttribute('incorrectAnswerTxt') : "Incorrect Answer");
					$(target)
						.attr("role", "mark")
						.prepend("<span class='sr-only'>" + incorrectAnswerTxt + ": </span>");
				} else {
					// otherwise, just confirm it's selected
					$(target).attr("role", "mark");
				}
				$pageContents.data("wrongFound")[currentGroup].push($(target).data("index"))
			}
		};

		// Check if enough words have been chosen in the find2 interaction
		function checkComplete(intType, currentGroup){
			if (intType == "find"){
				return ($pageContents.data("found")[currentGroup].length >= groupInfo[currentGroup].numSubGroups);
			}else if (intType == "find2"){
				if (x_currentPageXML.getAttribute("findShowNum") === "false") {
					return false;
				} else {
					return ($pageContents.data("found")[currentGroup].length + $pageContents.data("wrongFound")[currentGroup].length >= groupInfo[currentGroup].numSubGroups);
				}
			}
		};

		// Show the answers in the find2 interaction, in feedback and colors wrong and right answers
		function showAnswers(l_answers, l_options){
			var feedbackTxt = (x_currentPageXML.getAttribute('feedbackTxt') != undefined ? x_currentPageXML.getAttribute('feedbackTxt') : "Feedback");
			var groupTxt = (x_currentPageXML.getAttribute('groupTxt') != undefined ? x_currentPageXML.getAttribute('groupTxt') : "Group");
			var yourAnswerTxt = (x_currentPageXML.getAttribute('yourAnswerTxt') != undefined ? x_currentPageXML.getAttribute('yourAnswerTxt') : "Your Answer");
			var correctAnswerTxt = (x_currentPageXML.getAttribute('correctAnswerTxt') != undefined ? x_currentPageXML.getAttribute('correctAnswerTxt') : "Correct Answer");
			var incorrectAnswerTxt = (x_currentPageXML.getAttribute('incorrectAnswerTxt') != undefined ? x_currentPageXML.getAttribute('incorrectAnswerTxt') : "Incorrect Answer");
			var text = "<h3>" + feedbackTxt + "</h3><table class='full header shaded'> <thead><tr> <th>" + groupTxt + "</th><th>" + yourAnswerTxt + "</th><th>" + correctAnswerTxt + "</th></tr></thead><tbody>";

			for (var group = 0; group < correctAnswers.length; group++){
				if (groupInfo[group].name == "#distractor#")
				{
					continue;
				}
				text +=("<tr>");
				text += ("<td>" + groupInfo[group].name + "</td>");
				text += ("<td>");

				for (var i = 0; i < l_answers[group].length; i++){

					if (l_options[group][i].result === true) {
                            text += '<span id="feedbackResult" class="fa fa-fw fa-x-tick"><span class="sr-only"> ' + interactiveText.tickTxt + ': </span></span>';
                            text += (l_answers[group][i]);
					} else {
                            text += '<span id="finalResult" class="fa fa-fw fa-x-cross"><span class="sr-only"> ' + interactiveText.crossTxt + ': </span></span>'
                            text += (l_answers[group][i]);
					}
				}
				text += ("</td>");
				text +=("<td>");
				for (var i = 0; i < correctAnswers[group].length; i++){
					text +=(correctAnswers[group][i]);
				}
				text += ("</td>");
				text +=("</tr>");
			}
			text +=("</tbody></table>");

			$("#feedback").empty().append(text).show();

			// Add cross-through style for wrong answers
			var linethrough = ".wrongWord .wordOn";
			for(var group = 0; group < correctOptions.length; group++){
				linethrough += ", .wrongGroup" + group + ".wrongOn" + group;
				if (currentGroup != -1) {
					$("#passage .group.wrongOn" + group + " .sr-only").remove();
					$("#passage .group.wrongOn" + group)
						.attr("role", "mark")
						.prepend("<span class='sr-only'>" + incorrectAnswerTxt + ": </span>");
				}
			}
			linethrough += "{ text-decoration:line-through; }";
			$("#pageContents style").append(linethrough);
		}

		function finalFeedback(incorrect){
		    var correct = true;
		    for (var i =0; i < incorrect.length; i++) {
		        if (incorrect[i].length !== 0) {
		            correct =false;
				}
			}

            if(correct) {
				$("#passageHolder").addClass("disabled");
				$("#feedback").html('<p>' + (x_currentPageXML.getAttribute("findFeedback") != undefined ? x_currentPageXML.getAttribute("findFeedback") : "You have completed this activity.") + '</p>');
				$("#feedbackTxt").html("<span id='finalResult' class='fa fa-fw fa-x-tick'/>");
                $("#feedbackTxt").append((x_currentPageXML.getAttribute("passedFindTxt") != undefined ? x_currentPageXML.getAttribute("passedFindTxt") : "All selections are correct"));
				$("#passage .group").removeAttr("tabindex");
            } else {
				$("#feedbackTxt").html("<span id='finalResult' class='fa fa-fw fa-x-cross'/>");
                $("#feedbackTxt").append((x_currentPageXML.getAttribute("failedFindTxt") != undefined ? x_currentPageXML.getAttribute("failedFindTxt") : "You still have incorrect selections"));
            }
		}

		// only used in mcq interaction - creates new quiz
		this.createQuiz = function() {
			$pageContents.data({
				"mcqCurrentQ": -1,
				"mcqScore": 0,
				"mcqAnswers": [],
				"mcqAnswerOptions": []
			});

			$("#qText").show();
			$("#questionHolder").show();
			$("#fb").empty();
			$("#more").hide();

			// highlight shown for question can be either for all group or an individual sub group
			if (x_currentPageXML.getAttribute("mcqType") == "all") {
				for (var i=0; i<groupInfo.length; i++) {
					$pageContents.data("mcqAnswers").push(i);
				}
			} else {
				for (var i=0; i<subGroups.length; i++) {
					$pageContents.data("mcqAnswers").push(i);
				}
			}
			x_shuffleArray($pageContents.data("mcqAnswers"));

			var numQs = x_currentPageXML.getAttribute("mcqNumQs") == undefined || x_currentPageXML.getAttribute("mcqNumQs") == "*" ? $pageContents.data("mcqAnswers").length : isNaN(x_currentPageXML.getAttribute("mcqNumQs")) ? $pageContents.data("mcqAnswers").length : Number(x_currentPageXML.getAttribute("mcqNumQs"));
			$pageContents.data("mcqAnswers", $pageContents.data("mcqAnswers").slice(0, numQs));

			for (var i=0; i<groupInfo.length; i++) {
				$pageContents.data("mcqAnswerOptions").push({index:i, text:groupInfo[i].name});
			}
			$pageContents.data("mcqAnswers", $pageContents.data("mcqAnswers"));

			// start tracking
			this.startTracking();
			this.createQ();
		};

		// only used in mcq interaction - creates new question
		this.createQ = function() {
			$pageContents.data("mcqCurrentQ", $pageContents.data("mcqCurrentQ")+1);

			$("#fb").empty();
			$("#more").hide();
			$("#passage .group")
				.removeClass("on")
				.removeAttr("role");

			$("#qNum").html($pageContents.data("phrases").mcqQuesCount.replace("{i}", ($pageContents.data("mcqCurrentQ") + 1)).replace("{n}", $pageContents.data("mcqAnswers").length));
			$("#quizBtn")
				.button({"label":$pageContents.data("phrases").mcqBtnTxt})
				.data("state", 0)
				.button("disable");

			// turn on highlight & set up answers - correct answer plus number of random incorrect wrong answers
			var options = $pageContents.data("mcqAnswerOptions").slice(0),
				correct,
				name,
				correctFeedback = [];

			correctOptions = [];

			if (x_currentPageXML.getAttribute("mcqType") == "all") {
				$("#passage .group" + $pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")])
					.addClass("on")
					.attr("role", "mark");

				correct = options[$pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")]];
				options.splice($pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")], 1);
				name = $pageContents.data("mcqAnswerOptions")[$pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")]]['text'];
			} else {
				$("#passage .group[data-index='" + $pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")] + "']")
					.addClass("on")
					.attr("role", "mark");

				correct = options[subGroups[$pageContents.data("mcqAnswers")[$pageContents.data("mcqCurrentQ")]].ref];
				options.splice(correct.index, 1);
				name = $('#passage .on').html();
			}

			// Push the correct answers to correctOptions array
			correctOptions.push({
				id: correct['index'] + 1 + "",
				answer: correct['text'],
				result: true
			});
			correctFeedback.push($pageContents.data("phrases").mcqCorrect);

			x_shuffleArray(options);
			var numOptions = x_currentPageXML.getAttribute("mcqNumAs") == undefined ? 3 : x_currentPageXML.getAttribute("mcqNumAs") == "*" ? options.length + 1 : isNaN(x_currentPageXML.getAttribute("mcqNumAs")) ? 3 : Number(x_currentPageXML.getAttribute("mcqNumAs"));
			options = options.length <= numOptions - 1 ? options : options.slice(0, numOptions - 1);
			// options contains the added answers, add them to correctOptions, correctAnswers and correctDeedback
			$.each(options, function(i, thisOption){
				correctOptions.push({
					id: thisOption['index'] + 1 + "",
					answer: thisOption['text'],
					result: false
				});
				correctFeedback.push($pageContents.data("phrases").mcqWrong);
			});
			options.push(correct);

			x_shuffleArray(options);

			var answerText = [];
			answerText.push(correct['text']);

			XTEnterInteraction(x_currentPage, $pageContents.data("mcqCurrentQ"), 'multiplechoice', name, correctOptions, answerText, correctFeedback, x_currentPageXML.getAttribute("grouping"));
			var $optionHolder = $("#questionHolder #optionHolder")
					.html('<div class="optionGroup"><input type="radio" name="option" /><label class="optionTxt"></label></div>')
					.show();

			var	$optionGroup = $optionHolder.find(".optionGroup");
			for (i=0; i<options.length; i++) {
				var $thisOptionGroup;
				if (i != 0) {
					$thisOptionGroup = $optionGroup.clone().appendTo($optionHolder);
				} else {
					$thisOptionGroup = $optionGroup;
				}

				$thisOptionGroup.find("input")
					.attr({
						"value"	:options[i].index,
						"id"	:"option" + i
						})
					.change(function() {
						$("#quizBtn").button("enable");
					})
					.focusin(function() {
						$(this).parent().addClass("highlight");
					})
					.focusout(function() {
						$(this).parent().removeClass("highlight");
					});

				$thisOptionGroup.find(".optionTxt")
					.attr("for", "option" + i)
					.html(options[i].text);
			}
		};

		this.startTracking = function() {
			var numQs = x_currentPageXML.getAttribute("mcqNumQs") == undefined || x_currentPageXML.getAttribute("mcqNumQs") == "*" ? $pageContents.data("mcqAnswers").length : isNaN(x_currentPageXML.getAttribute("mcqNumQs")) ? $pageContents.data("mcqAnswers").length : Number(x_currentPageXML.getAttribute("mcqNumQs")),
				weighting = (x_currentPageXML.getAttribute("trackingWeight") != undefined) ? x_currentPageXML.getAttribute("trackingWeight") : 1.0;
			XTSetPageType(x_currentPage, 'numeric', numQs, weighting);
		};

		this.finishTracking = function() {
			// if this is a find2 interaction
			if (x_currentPageXML.getAttribute("interactivity") == "find2")
				{
					interactiveText.endFindInteraction();
					$("#passageHolder").addClass("disabled");
					return;
				}

			//used for mcq:
			var numQs = x_currentPageXML.getAttribute("mcqNumQs") == undefined || x_currentPageXML.getAttribute("mcqNumQs") == "*" ? $pageContents.data("mcqAnswers").length : isNaN(x_currentPageXML.getAttribute("mcqNumQs")) ? $pageContents.data("mcqAnswers").length : Number(x_currentPageXML.getAttribute("mcqNumQs"));

			if (numQs === 0) {
				XTSetPageScore(x_currentPage, $pageContents.data("mcqScore"), x_currentPageXML.getAttribute("trackinglabel"));
			} else {
				XTSetPageScore(x_currentPage, $pageContents.data("mcqScore") * 100 / numQs, x_currentPageXML.getAttribute("trackinglabel"));
			}
		};
	};

	interactiveText.init();
</script>

<div id="pageContents">

	<div id="passageHolder" class="panel">
		<div id="passage"/>
		<div id="feedbackTxt" aria-live="polite"/>
	</div>
	<div>
		<div id="pageTxt"/>
		<div id="instructions"/>
		<div id="groupInfo" aria-live="polite"/>
		<div id="btnHolder"/>
		<div id="questionHolder"/>
	</div>

	<div id="feedback" aria-live="polite"/>

</div>

