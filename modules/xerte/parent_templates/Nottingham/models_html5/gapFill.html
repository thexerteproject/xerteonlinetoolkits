 <script type="text/javascript">
/**
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.

 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
	
	// pageChanged & sizeChanged functions are needed in every model file
	// other functions for model should also be in here to avoid conflicts
	var gapFill = new function() {

		var labelTxt,
			delimiter,
			finished = false,
			correct_answers = 0,
			total = 0,
			score = 0,
			attempts = 0,
			casesensitive,
			answerData,
			allDropDownAnswers,
			labelAnswers = {},
			$pageContents,
			$targetHolder,
			$feedbackTxt,
			$audioHolder;

		this.tickTxt = x_getLangInfo(x_languageData.find("tick")[0], "title") != undefined ? x_getLangInfo(x_languageData.find("tick")[0], "title") : "Correct";
		this.crossTxt = x_getLangInfo(x_languageData.find("cross")[0], "title") != undefined ? x_getLangInfo(x_languageData.find("cross")[0], "title") : "Incorrect";
		this.correctedTxt = x_getLangInfo(x_languageData.find("cross")[0], "corrected") != undefined ? x_getLangInfo(x_languageData.find("cross")[0], "corrected") : "Corrected answer";

		// function called every time the page is viewed after it has initially loaded
		this.pageChanged = function() {
			// make sure we are using data for this specific page & not a different page of this type
			$pageContents = $("#pageContents");
			$targetHolder = $("#targetHolder");
			$feedbackTxt = $("#feedbackTxt");
			$audioHolder = $("#audioHolder");
			
			casesensitive = $pageContents.data('casesensitive');
			answerData = $pageContents.data('answerData');
			allDropDownAnswers = $pageContents.data('allDropDownAnswers');
			labelAnswers = $pageContents.data('labelAnswers');
			finished = $pageContents.data('finished');
			score = $pageContents.data('score');
			attempts = $pageContents.data('attempts');
			
			if (XTGetMode() == "normal") { this.isTracked = true; }
			
			$pageContents.find("#hint").remove();
		}

		// triggered on leaving the page
        this.leavePage = function() {
			// keep important data for later views of page
			$pageContents.data({
				'casesensitive': casesensitive,
				'answerData': answerData,
				'allDropDownAnswers': allDropDownAnswers,
				'labelAnswers': labelAnswers,
				'finished': finished,
				'score': score,
				'attempts': attempts
			});

			// auto submit answers
			if (finished == false) {
				if(x_currentPageXML.getAttribute("interactivity") == "Drag Drop")
				{
					this.dragDropSubmit(true);
				}
				else if(x_currentPageXML.getAttribute("interactivity") == "Fill in Blank")
				{
					this.fillInSubmit(true);
				}
				else if (x_currentPageXML.getAttribute("interactivity") == "Drop Down Menu")
				{
					this.dropDownSubmit(true);
				}
			}
        };
		
		// function called every time the size of the LO is changed
		this.sizeChanged = function() {
			// set panel to appropriate size (at least full height of page)
			var $panel = $("#mainPanel");
			$panel.css("min-height", x_getAvailableHeight([$panel]));
			$pageContents.find("#hint").remove();

			// resize any audio players in feedback blocks
			if ($audioHolder.length > 0) {
				this.audioFbResize();
			}

			if (x_currentPageXML.getAttribute("interactivity") == "Drag Drop") {
				this.dragDropPosition();
			} else {
				$targetHolder.find("input, select").css("font-size", $("#dragDropHolder").css("font-size"));
			}
		}

		// ensure audio players in feedback block are an appropriate width
		this.audioFbResize = function(show) {
			if (show === true) {
				$audioHolder.show();
			}
			
			if ($audioHolder.is(":visible")) {
				var audioBarW = 0;
				$("#pageContents #audioHolder .mejs-inner .mejs-controls").children().each(function() {
					audioBarW += $(this).outerWidth();
				});

				// trigger mediaplayer resize functions if the audio player is not an appropriate width
				if (audioBarW - $targetHolder.width() < -2 || audioBarW - $targetHolder.width() > 2) {
					$x_window.resize();
				}
			}
		}

		// initial set up of page on first view
		this.init = function() {
			$pageContents = $("#pageContents");
			$targetHolder = $("#targetHolder");
			$feedbackTxt = $("#feedbackTxt");
			$audioHolder = $("#audioHolder");

			$("#showBtn").hide();

			// get the delimiter used to mark up the gaps in the gap fill text
			delimiter = x_currentPageXML.getAttribute("answerDelimiter") != undefined && x_currentPageXML.getAttribute("answerDelimiter") != "" ? x_currentPageXML.getAttribute("answerDelimiter")  : ",";

			// is project in tracking mode? if so, only one attempt is possible
			if(XTGetMode() == "normal") {
                this.isTracked = true;
            } else {
				this.isTracked = false;
			}
			
			// page layout
			var panelWidth = x_currentPageXML.getAttribute("panelWidth");
			if (panelWidth == "Full") {
				$("#mainText").remove();
				$("#dragDropHolder").appendTo($pageContents);
				$("#pageContents .splitScreen").remove();
			} else {
				$("#mainText").html(x_addLineBreaks(x_currentPageXML.getAttribute("text")));
				if (panelWidth == "Small") {
					$("#pageContents .splitScreen").addClass("large");
				} else if (panelWidth == "Large") {
					$("#pageContents .splitScreen").addClass("small");
				} else {
					$("#pageContents .splitScreen").addClass("medium");
				}
			}

			// origPassage is the gap fill text - replace p tags with br tags
			var	origPassage = x_addLineBreaks(x_currentPageXML.getAttribute("passage"));
			if (origPassage.indexOf("<p>") != -1){
				origPassage = origPassage.replace(/<p>/gi,"").replace(/<\/p>/gi,"<br/><br/>");
			}

			// split gap fill text up around gaps
			var passageArray = origPassage.split(x_currentPageXML.getAttribute("mainDelimiter") != undefined && $.trim(x_currentPageXML.getAttribute("mainDelimiter")) != "" ? x_currentPageXML.getAttribute("mainDelimiter") : "|"),
				markedWord = false,
				i, j;
			
			answerData = []; // contains array of possible correct texts for blanks
			allDropDownAnswers = [];

			// drop down mode: get delimiter separating the options to be shown in the combo boxes
			// & get distractors - these are added to every combo box
			var dropDownDelimiter,
				dropDownNoise;
			if (x_currentPageXML.getAttribute("interactivity") == "Drop Down Menu") {
				dropDownDelimiter = x_currentPageXML.getAttribute("dropDownDelimiter") != undefined && x_currentPageXML.getAttribute("dropDownDelimiter") != "" ? x_currentPageXML.getAttribute("dropDownDelimiter")  : "/";

				if (x_currentPageXML.getAttribute("noise") != undefined && x_currentPageXML.getAttribute("noise") != "") {
					var noiseDelimiter = x_currentPageXML.getAttribute("noiseDelimiter") != "" && x_currentPageXML.getAttribute("noiseDelimiter") != undefined ? x_currentPageXML.getAttribute("noiseDelimiter") : " ";
					dropDownNoise = x_currentPageXML.getAttribute("noise").split(noiseDelimiter);
				}
			}
			
			// get aria-label for input or select when in fill in blank or drop down mode
			var answerFieldLabel = x_currentPageXML.getAttribute("answerFieldLabel");
			if (answerFieldLabel === undefined | answerFieldLabel === null) {
				answerFieldLabel = "Answer";
			}

			// create passage containing inputs (fill blank), selects (drop down) & spans (drag drop) as well as static text
			var gapFillStr = "",
				decodedAnswer;
			
            for (i=0; i<passageArray.length; i++) {
				if (markedWord == false) {
					// static text (not a blank)
					gapFillStr += '<span class="staticTxt">' + passageArray[i] + '</span>';
					markedWord = true;

				} else {
					// a blank to be filled
					// keep track of correct answers from each blank in answerData array
					decodedAnswer = $("<textarea/>").html(passageArray[i]).text();

					if (x_currentPageXML.getAttribute("interactivity") == "Drag Drop") {
						// create span used for target area
						gapFillStr += '<span id="gap' + (i-1)/2 + '" class="target highlight" tabindex="0">' + decodedAnswer + '</span>';
						answerData.push(decodedAnswer.split(delimiter));

					} else if (x_currentPageXML.getAttribute("interactivity") == "Drop Down Menu") {
						var answer = $("<div>").html(decodedAnswer).text();
						var allAnswers = answer.split(dropDownDelimiter);
						answerData.push(allAnswers[0].split(delimiter));
						
						// options in combo boxes include all correct answers (1st answers separated by delimiter ","), all incorrect answers (subsequent answers separated by dropDownDelimiter "/") & all noise answers (separated by noiseDelimiter)
						// e.g. dog,cat/fish/bird - where dog & cat are correct answers & fish & bird are distractors
						allAnswers = allAnswers.concat(allAnswers[0].split(delimiter));
						allAnswers.splice(0,1);
						if (dropDownNoise != undefined) {
							allAnswers = allAnswers.concat(dropDownNoise);
						}

						// sort combo box options alphabetically & then remove any duplicate options
						allAnswers.sort();
						for (j=0; j<allAnswers.length; j++) {
							while (allAnswers[j] == allAnswers[j+1]) {
								allAnswers.splice(j+1,1);
							}
						}

						// randomise option order if required
						var dropDownSort = x_currentPageXML.getAttribute("dropDownSort");
						if (dropDownSort != undefined && dropDownSort != "" && dropDownSort != "alphabetic") {
							allAnswers.sort(
									function () {
										return Math.random() - 0.5;
									}
							);
						}

						allDropDownAnswers.push(allAnswers);

						// create combo box
						gapFillStr += '<select id="gap' + (i-1)/2 + '" class="menu" tabindex="0" aria-label="' + answerFieldLabel + ' ' + (1+(i-1)/2) + '">';
						gapFillStr += '<option value=" "> </option>';
						for (var j=0; j<allAnswers.length; j++) {
							gapFillStr += '<option value="' + allAnswers[j] + '">' + allAnswers[j] + '</option>';
						}
						gapFillStr += '</select>';
						
					} else { // fill in the blank
						// create input field
						var answer = $("<div>").html(decodedAnswer).text();
						gapFillStr += '<input type="text" id="gap' + (i-1)/2 + '" value="' + answer + '" tabindex="0" aria-label="' + answerFieldLabel + ' ' + (1+(i-1)/2) + '" autocapitalize="none" autocomplete="off" autocorrect="off" spellcheck="false" />';

						var tempArray = [];
						tempArray = answer.split(delimiter);

						// answers may be case-sensitive
						casesensitive = x_currentPageXML.getAttribute("casesensitive") != "true" && x_currentPageXML.getAttribute("casesensitive") != "1" ? false : true;
						if (!casesensitive) {
							for (var j=0; j < tempArray.length; j++) {
								tempArray[j] = tempArray[j].toLowerCase();
							}
						}
						answerData.push(tempArray);
					}
					markedWord = false;
				}
			}
			
			var $gapFillTxt = $('<div>' + gapFillStr + '</div>').appendTo($targetHolder);
			
			// remove any staticTxt tags that have other staticTxt tags in them - in FF these can make you get stuck in loop when tabbing and unable to reach blanks
			// these tags are added when layout uses tables
			$gapFillTxt.find('.staticTxt').each(function() {
				var $parent = $(this).parents('.staticTxt');
				if ($parent.length > 0) {
					$parent[0].removeAttribute('tabindex');
					$parent.removeClass('staticTxt');
				}
			});

			// continue with set up specific to each mode
			if (x_currentPageXML.getAttribute("interactivity") == "Drag Drop") {
				// store data about all possible combo box answers
				$gapFillTxt.find(".target").each(function() {
					$(this).data("answer", $(this).html());
				});
				$("#dragDropHolder").addClass('dragDrop');
				this.setUpDragDrop();

			} else if (x_currentPageXML.getAttribute("interactivity") == "Drop Down Menu") {
				$("#dragDropHolder").addClass('dropDown');
				this.setUpDropDown();

			} else { // fill in blank
				$("#dragDropHolder").addClass('fillBlank');
				this.setUpFillBlank();
			}

			// set up feedback block
			if (x_currentPageXML.getAttribute("audioFeedback") != "" && x_currentPageXML.getAttribute("audioFeedback") != undefined) {
				$audioHolder.mediaPlayer({
					type	:"audio",
					source	:x_currentPageXML.getAttribute("audioFeedback"),
					width	:"100%"
				});
				
				// manually add a transcript button to the end of the audio bar
				if (x_currentPageXML.getAttribute('audioTranscript') != undefined && x_currentPageXML.getAttribute('audioTranscript') != '') {
					x_addAudioTranscript($audioHolder, x_currentPageXML.getAttribute('audioTranscript'));
				}
				$audioHolder.hide();
			} else {
				$audioHolder.remove();
			}

			// start tracking
            this.initTracking();

            // set up the tracking of interactions for this page
            var interactionNumber,
				name,
				correctAnswer,
				correctAnswers,
				correctOption,
				correctOptions;

			// fill blank mode
			if(x_currentPageXML.getAttribute("interactivity") == "Fill in Blank"){			
				for (interactionNumber=0;  interactionNumber<answerData.length;  interactionNumber++) {
					name = "interaction number" + " " + interactionNumber;
					correctAnswer = answerData[interactionNumber];
					XTEnterInteraction(x_currentPage,  interactionNumber , 'fill-in', name, [], correctAnswer, "Correct", x_currentPageXML.getAttribute("grouping"));
				}
			}
			// drag drop mode
			else if(x_currentPageXML.getAttribute("interactivity") == "Drag Drop"){
			    correctAnswers = [];
                correctOptions = [];
                name = x_currentPageXML.getAttribute("name");
				if (x_currentPageXML.getAttribute("trackinglabel") != null && x_currentPageXML.getAttribute("trackinglabel") != "")
				{
					name = x_currentPageXML.getAttribute("trackinglabel");
				}
				for (interactionNumber=0;  interactionNumber<answerData.length;  interactionNumber++) {
					correctAnswer = answerData[interactionNumber][0];
					correctAnswer = correctAnswer + "-->" + interactionNumber;
					correctAnswers.push(correctAnswer);
					correctOption = {source: answerData[interactionNumber][0], target: interactionNumber + ''}
					correctOptions.push(correctOption);
				}
                XTEnterInteraction(x_currentPage,  0 , 'match', name, correctOptions, correctAnswers, "", x_currentPageXML.getAttribute("grouping"));
            }
			// drop down mode
			else{
                for (interactionNumber=0;  interactionNumber<answerData.length;  interactionNumber++) {
                    correctAnswers = [];
                    correctOptions = [];
                    name = "interaction number" + " " + interactionNumber;
                    for (i=0; i<answerData[interactionNumber].length; i++) {
                        correctAnswers.push(answerData[interactionNumber][i]);
                    }
                    for (i=0; i<allDropDownAnswers[interactionNumber].length; i++)
					{
					    var correctAnswer = false;
					    var p = answerData[interactionNumber].indexOf(allDropDownAnswers[interactionNumber][i]);
                        if (p >=0)
                        {
                            correctAnswer = true;
                        }

                        correctOptions.push({
                            id: (i + 1) + "",
                            answer: allDropDownAnswers[interactionNumber][i],
                            result: correctAnswer
                        });
					}
                    XTEnterInteraction(x_currentPage,  interactionNumber , 'multiplechoice', name, correctOptions, correctAnswers, "Correct", x_currentPageXML.getAttribute("grouping"));
                }
			}
			
			this.sizeChanged();
			x_pageLoaded();
		}

		// drop down mode: set up combo box exercises
		this.setUpDropDown = function() {
			$("#labelHolder").remove();

			// spacing of lines within the gap fill text area
			if (x_currentPageXML.getAttribute("spaceLines") != "false") {
				$targetHolder.find("span").css("line-height", $targetHolder.find("select").outerHeight() + 12 + "px");
			}

			// drop down menu mode can only be set to mark at end - no immediate marking option available
			// set up submit button
			$("#submitBtn")
				.button({
					label:	x_currentPageXML.getAttribute("checkBtn") != undefined && x_currentPageXML.getAttribute("checkBtn") != "" ? x_currentPageXML.getAttribute("checkBtn") : "Check"
				})
				.click(function() {
                    gapFill.dropDownSubmit();
				});

			// set up button to show correct answers
			$("#showBtn")
				.button({
					label:	x_currentPageXML.getAttribute("showBtn") != undefined && x_currentPageXML.getAttribute("showBtn") != "" ? x_currentPageXML.getAttribute("showBtn") : "Show Answers"
				})
				.click(function() {
					// show the correct answers for gaps that aren't already filled correctly
					$targetHolder.find("select").each(function(i) {
						var $this = $(this);
						if (!$this.hasClass("correct")) {
							// remove the screen reader only 'incorrect' text
							if ($this.hasClass("incorrect") && $this.prev().hasClass("sr-only")) {
								$this.prev().remove();
							}

							$this
								.val(answerData[i][0]) // if there are several correct answers - show the first
								.attr("disabled", "disabled")
								.addClass("answerShown")
								.removeClass("incorrect")
								.before('<span class="sr-only"> ' + gapFill.correctedTxt + ': </span>');
						}
					});

					// show feedback & hide buttons
					$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
					x_pageContentsUpdated();
					gapFill.audioFbResize(true);
					$(this).hide();
					$("#submitBtn").hide();
					
					finished = true;
				});

			// reset feedback everytime answers are changed
			$targetHolder.find("select").on("change", function() {
				$feedbackTxt.find("#txt").html("");
			});
		}

		// fill blank mode: set up fill in the blank text box exercises
		this.setUpFillBlank = function() {
			$("#labelHolder").remove();

			// spacing of lines within the gap fill text area
			if (x_currentPageXML.getAttribute("spaceLines") != "false") {
				$targetHolder.find("span").css("line-height", $targetHolder.find("input").outerHeight() + 12 + "px");
			}

			// get length of longest correct answer and make all inputs this width
			var	maxW = 0, i;
			$targetHolder.find("input").each(function() {
				const $this = $(this);
				const answers = $this.attr("value").split(delimiter);
				const longest = answers.sort(function (a, b) { return b.length - a.length; })[0];
				$this.attr("value", longest);
				maxW = Math.max(maxW, $this.val().length);
			});
			
			$targetHolder.find("input")
				.attr({
					"size"		:maxW + 2,
					"maxlength"	:maxW + 2,
					"value"		:""
				})
				.each(function() {
					$(this).data("index", $targetHolder.find("input").index($(this))); // stored here as using .index() won't return result needed as there are other elements (line breaks etc.) in $targetHolder
				});

			// if answers are not judged, force mark at end
			let judge = true;
			if(x_currentPageXML.getAttribute("judge") === 'false'){
				judge = false;
			}

			// mark immediately
			if ((x_currentPageXML.getAttribute("markEnd") == undefined || x_currentPageXML.getAttribute("markEnd") == "false") && !this.isTracked && judge) {
				$("#submitBtn, #showBtn").remove();
				
				$targetHolder.find("input")
					.addClass("incorrect")
					.on("keypress", function() {
						if (finished == false) {
							var $this = $(this);

							setTimeout(function() {
								var currvalue = !casesensitive ? $this.val().trim().toLowerCase() : $this.val().trim();
								if (answerData[$this.data("index")].indexOf(currvalue) != -1) {
									// correct answer entered
									$this
										.addClass("correct judged")
										.removeClass("incorrect")
										.attr({
											"disabled": "true",
											"readonly": "readonly"
										})
										.before('<span class="sr-only"> ' + gapFill.tickTxt + '</span>');

									$this.siblings().each(function() {
										if ($(this).is("input") && $(this).index() > $this.index() && !$(this).hasClass("correct")) {
											$(this).focus();
											return false;
										}
									});

									$pageContents.find("#hint").remove();

									// exercise completed (all correct answers entered) - show feedback
									if ($targetHolder.find("input.correct").length == $targetHolder.find("input").length) {
										$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
										x_pageContentsUpdated();
										gapFill.audioFbResize(true);
									}

								} else {
									// wrong answer currently entered
									if (x_currentPageXML.getAttribute("showHint") != "false") {
										// start showing hint after 3 wrong characters entered
										// only show hint if there's only 1 possible correct answer for the gap
										var wrong = 0;
										for (i=0; i<$this.val().length; i++) {
											if (answerData[$this.data("index")].length == 1 && (i+1 > answerData[$this.data("index")][0].length || currvalue[i] != answerData[$this.data("index")][0][i])) {
												wrong++;
											}
										}

										if (wrong > 0) {
											// keep track of no. of attempts
											if ($this.data("attempt") == undefined) {
												$this.data("attempt", 1);

											} else if ($this.data("attempt") >= (x_currentPageXML.getAttribute("attemptsBeforeHint") != undefined && $.isNumeric(x_currentPageXML.getAttribute("attemptsBeforeHint")) ? Number(x_currentPageXML.getAttribute("attemptsBeforeHint")) : 2)) {
												// show hint - add extra letter every time two more incorrect characters are entered
												$this.data("attempt", $this.data("attempt")+1);
												if ($this.data("attempt") % 2 != 0) {
													var currentHint = $this.data("hint"),
														correctAnswer = answerData[$this.data("index")][0]

													if (currentHint == undefined) {
														// 1st hint will be 1st letter
														currentHint = "";
														for (i=0; i<correctAnswer.length; i++) {
															if (i == 0) {
																currentHint += correctAnswer[i];
															} else {
																currentHint += "_";
															}
														}

													} else if (currentHint[currentHint.length - 1] == "_") {
														// 2nd hint will be last letter
														currentHint = currentHint.substring(0, currentHint.length - 1) + correctAnswer[correctAnswer.length - 1];

													} else {
														// subsequent hints are random other letters
														var blanks = currentHint.match(/_/g); // num of blanks

														if (blanks != null && blanks.length >= 1) {
															var	letterToShow = Math.floor(Math.random() * blanks.length),
																	tempCount = 0;
															for (i=0; i<currentHint.length; i++) {
																if (currentHint[i] == "_" && tempCount == letterToShow) {
																	currentHint = currentHint.substring(0, i) + correctAnswer[i] + currentHint.substring(i + 1, currentHint.length);
																	break;
																} else if (currentHint[i] == "_") {
																	tempCount++;
																}
															}
														}
													}

													$this
														.data("hint", currentHint)
														.attr("title", currentHint);

													// hint is shown as a tooltip
													var $hint = $pageContents.find("#hint");
													if ($hint.length < 1) {
														$pageContents.append('<div id="hint" class="x_tooltip"></div>');
														$hint = $pageContents.find("#hint");
													}
													$hint
														.html(currentHint)
														.css({
															top	 :$this.position().top + parseInt($("#mainPanel").css("padding-top")) + parseInt($this.css("margin-top")) + $this.height() + 10,
															left :$this.position().left + parseInt($("#mainPanel").css("padding-left")) + 5
														});
												}

											} else {
												$this.data("attempt", $this.data("attempt")+1);
											}
										}
									}
								}
							}, 10);
						}
					});

				if (x_currentPageXML.getAttribute("showHint") != "false") {
					$targetHolder.find("input").keydown(function(e) {
						var charCode = e.charCode || e.keyCode;
						if (charCode == 27 && $("#hint.x_tooltip").length > 0) {
							// escape key will close any open hint tooltips
							$("#hint.x_tooltip").remove();
						}
					});
				}
				
			} else {
				// when mark at end, have show answers button after a no. of attempts instead of a hint

				// remove any incorrect styling when input text is changed
				$targetHolder.find("input")
					.on("keypress focus", function() {
						$(this).removeAttr("incorrect");
					});

				// set up submit button to marks answers
				$("#submitBtn")
					.button({
						label:	x_currentPageXML.getAttribute("checkBtn") != undefined && x_currentPageXML.getAttribute("checkBtn") != "" ? x_currentPageXML.getAttribute("checkBtn") : "Check"
					})
					.click(function() {
                        gapFill.fillInSubmit();
					});

				// set up button to show correct answers unless judge is off
				if (judge) {
					$("#showBtn")
						.button({
							label:	x_currentPageXML.getAttribute("showBtn") != undefined && x_currentPageXML.getAttribute("showBtn") != "" ? x_currentPageXML.getAttribute("showBtn") : "Show Answers"
						})
						.click(function() {
							$targetHolder.find("input").each(function() {
								var $this = $(this);

								// disable all text input fields
								$this.attr({
									"readonly": "readonly",
									"disabled": "true"
								});

								// show correct answers of any blanks that aren't filled correctly
								if (!$this.hasClass("correct")) {
									// remove the screen reader only 'incorrect' text
									if ($this.hasClass("incorrect") && $this.prev().hasClass("sr-only")) {
										$this.prev().remove();
									}

									$this.val(answerData[$this.data("index")][0]);
									$this
										.addClass("answerShown")
										.removeClass("incorrect")
										.before('<span class="sr-only"> ' + gapFill.correctedTxt + ': </span>');
								}
							});

							// show feedback & hide buttons
							$(this).hide();
							$("#submitBtn").hide();
							$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
							x_pageContentsUpdated();
							gapFill.audioFbResize(true);

							finished = true;
						});
				}
			}

			// hide feedback text when any input text is changed
			$targetHolder.find("input").on("keypress", function() {
				if (finished == false) {
					$feedbackTxt.find("#txt").html("");
				}
			});
		}

		// drag drop mode: set up drag & drop exercises
		this.setUpDragDrop = function() {
			// get distractor info that will be used later
			let distractors = [];
			if (x_currentPageXML.getAttribute("noise") != undefined && x_currentPageXML.getAttribute("noise") != "") {
				const noiseDelimiter = x_currentPageXML.getAttribute("noiseDelimiter") != "" && x_currentPageXML.getAttribute("noiseDelimiter") != undefined ? x_currentPageXML.getAttribute("noiseDelimiter") : " ";
				distractors = x_currentPageXML.getAttribute("noise").split(noiseDelimiter);
			}

			// mark immediately (can only drop labels on correct targets)
			if (!this.isTracked && (x_currentPageXML.getAttribute("markEnd") == undefined || x_currentPageXML.getAttribute("markEnd") == "false")) {
                $("#submitBtn").hide();
				$("#feedbackTxt").prepend("<div id='tryAgain' aria-live='polite'></div>");

			// mark when submit button clicked
			// if mark at end is off but tracking is on then it will mark at end anyway
			} else {
				// set up submit button
				$("#submitBtn")
					.button({
						label:	x_currentPageXML.getAttribute("checkBtn") != undefined && x_currentPageXML.getAttribute("checkBtn") != "" ? x_currentPageXML.getAttribute("checkBtn") : "Check"
					})
					.click(function() {
						gapFill.dragDropSubmit();
					});

				// set up button to show correct answers
				$("#showBtn")
					.button({
						label:	x_currentPageXML.getAttribute("showBtn") != undefined && x_currentPageXML.getAttribute("showBtn") != "" ? x_currentPageXML.getAttribute("showBtn") : "Show Answers"
					})
					.click(function() {
						// disable targets that haven't had correct labels placed on them
						var $incorrectTargets = $("#targetHolder .target").filter(function () {
							return $(this).data("correct") != true || !$(this).hasClass("correct");
						});

						$incorrectTargets.each(function() {
							if ($(this).data("width") != undefined) {
								$(this).width("auto");
							}
						});

						$incorrectTargets
							.addClass("answerShown highlight")
							.removeClass("incorrect highlightDark")
							.removeAttr("aria-label tabindex")
							.off("keypress focusin focusout click")
							.each(function() {
								// add correct answer text to the target
								$(this)
									.html($(this).data("answer"))
									.prepend('<span class="sr-only"> ' + gapFill.correctedTxt + ': </span>');
							});

						// hide any labels that haven't been placed
						$("#labelHolder").hide();

						// show feedback & hide buttons
						$(this).hide();
						$("#submitBtn").hide();
						$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
						x_pageContentsUpdated();
						gapFill.audioFbResize(true);
						
						finished = true;
					});
			}

			// strings used for label & target titles (for screen readers)
			labelTxt = x_getLangInfo(x_languageData.find("interactions").find("draggableItem")[0], "selected", "Item Selected");
			var labelTxt1 = x_getLangInfo(x_languageData.find("interactions").find("draggableItem")[0], "name", "Draggable Item")
			var targetTxt = x_getLangInfo(x_languageData.find("interactions").find("blank")[0], "name", "Blank");
			
			// set up targets
			var	maxW = 0,
				i,
				tolerance = "pointer", // to make it easier to drop labels on different gap sizes, use a different tolerance depending on whether the gap is as long as widest text or smaller
				compress = true;

			// there are options for how wide the gap will be:
			if (x_currentPageXML.getAttribute("gapSize") == "bespoke" && $.isNumeric(x_currentPageXML.getAttribute("gapBespokeSize"))) {
				// bespoke - author can enter width (in pixels) in editor
				maxW = Number(x_currentPageXML.getAttribute("gapBespokeSize"));
			} else if (x_currentPageXML.getAttribute("gapSize") == "correct") {
				// gap is as wide as the correct text
				maxW = "auto";
			} else if (x_currentPageXML.getAttribute("gapSize") == "min") {
				// gap is compressed to 40px wide
				maxW = 40;
			} else {
				// gap is as wide as the longest text
				$targetHolder.find(".target").each(function() {
					// add longest correct answer to each blank and take the width of the widest one
					const $this = $(this);
					const answers = $this.html().split(delimiter);
					const longest = answers.sort(function (a, b) { return b.length - a.length; })[0];
					$this.html(longest);
					maxW = Math.max(maxW, $this.width());
				});

				// check none of the distractor labels are longer
				const $tempTarget = $('<span class="target highlight"></span>').appendTo($targetHolder);
				for (i=0; i<distractors.length; i++) {
					$tempTarget.html(distractors[i]);
					maxW = Math.max(maxW, $tempTarget.width());
				}
				$tempTarget.remove();

				maxW += 30;
				$("#dragDropHolder").addClass("contain");
				tolerance = "intersect";

				if (x_currentPageXML.getAttribute("gapSizeFilled") != "true") {
					// gap will maintain its width and not be compressed after label has been dropped - other width options will always compress
					compress = false;
					$("#targetHolder").addClass("noCompress");
				}
			}

			$("#targetHolder").data("compress", compress);

			$targetHolder.find(".target").each(function(i) {
				$(this)
					.attr("title", targetTxt + " " + (i + 1))
					.data("index", i)
					.css({
						"width": maxW == "auto" ? $(this).width() : maxW,
						"height":$(this).height() + 10,
						"line-height":$(this).height() + 10 + "px"
					})
					.html("") // this is blank until a label is dropped on it
					.droppable({
						tolerance: tolerance,
						drop: function(event, ui) {
							gapFill.dropLabel($(this), ui.draggable);
						}
					});

				if (compress == true) {
					// gap may reduce in width after label has been dropped on it - keep track of original width in case it's reset later
					$(this).data("width", $(this).width())
				}
			});

			this.setUpTargetListeners($targetHolder.find(".target"));

			// allow labels to be dragged back to the target holder unless mark at end is off (as not needed as will only be placed on correct targets)
			if (this.isTracked || x_currentPageXML.getAttribute("markEnd") == "true") {
				$("#labelHolder").droppable({
					drop: function (event, ui) {
						gapFill.dropLabel($(this), ui.draggable)
					}
				});

				this.setUpTargetListeners($("#labelHolder"));
			}

			// spacing of lines within the gap fill text area
			if (x_currentPageXML.getAttribute("spaceLines") != "false") {
				$targetHolder.find("span:not(.target)").css("line-height", parseInt($targetHolder.find(".target").css("line-height")) + 10 + "px");
			}

			// set up labels
			var allLabels = answerData.slice();

			// create distractor labels as well as correct answer labels
			for (i=0; i<distractors.length; i++) {
				allLabels.push([distractors[i]]);
			}

			// create labels
			var	tempMultiAnswers = [];
			for (i=0; i<allLabels.length; i++) {
				var arrayString = "";
				for (var j=0; j<allLabels[i].length; j++) {
					if (j != 0) {
						arrayString += delimiter;
					}
					arrayString += allLabels[i][j];
				}

				// some activities may have gaps where answers are correct in any order - only create the labels for these once
				// e.g. the primary colours are |red,yellow,blue|, |red,yellow,blue| and |red,yellow,blue|
				if (tempMultiAnswers.indexOf(arrayString) == -1) {
					for (var j=0; j<allLabels[i].length; j++) {
						$('<div class="label panel"><span class="sr-only">' + labelTxt1 + '</span>' + allLabels[i][j] + '</div>')
							.appendTo($("#labelHolder"))
							.data("answer", arrayString);
					}
					if (allLabels[i].length > 1) {
						tempMultiAnswers.push(arrayString);
					}
				}
			}

			// randomise the order of the labels
			var labels = $("#labelHolder .label").sort(function() { return (Math.round(Math.random())-0.5); });
			for (i=0; i<labels.length; i++) {
				$(labels[i])
					.appendTo($("#labelHolder"))
					.attr({
						"id": "index" + i,
						"tabindex":	0
					});
			}

			// set label up to be draggable (with mouse)
			$("#dragDropHolder .label")
				.draggable({
					containment:	$("#dragDropHolder").hasClass("contain") ? "#dragDropHolder" : false, // don't restrict labels to dragDropHolder when target areas may be small as this can make it very hard to drop labels
					stack:			"#dragDropHolder .label", // item being dragged is always on top (z-index)
					revert:			"invalid", // snap back to original position if not dropped on target
					start:			function(event, ui) {
						$("#tryAgain").empty();

						// remove any focus/selection highlights made by tabbing to labels/targets
						if ($("#labelHolder .label.focus").length > 0) {
							$("#labelHolder .label.focus").removeAttr("aria-label");
						}
						if ($pageContents.data("selectedLabel") != undefined && $pageContents.data("selectedLabel") != "") {
							$pageContents.data("selectedLabel").removeAttr("aria-label");
							$pageContents.data("selectedLabel", "");
						}
						$("#dragDropHolder .selected").removeClass("selected");
						$("#dragDropHolder .focus").removeClass("focus");
						$("#dragDropHolder .highlightDark").removeClass("highlightDark");
						ui.helper.css("opacity", 1);
					},
					stop: function(event, ui) {
						if (ui.helper.data("dragged")) {
							// dropped successfully
							ui.helper.css("opacity", 0);

						} else if (x_currentPageXML.getAttribute("tryAgain") != undefined && x_currentPageXML.getAttribute("tryAgain") != "") {
							// not dropped on a valid target
							$("#tryAgain").html('<p>'+x_currentPageXML.getAttribute("tryAgain")+'</p>');
							$feedbackTxt.find("#txt").html("");
						}
					}
				})
				.disableSelection();

			// set up event listeners used when selecting / moving label with keyboard
			this.setUpLabelListeners($("#dragDropHolder .label"));

			// specify which labels can be dropped on each target
			// if mark at end is on - labels can be dropped on all targets
			// if mark at end is off - labels can only be dropped on correct targets
			for (i=0; i<$("#targetHolder .target").length; i++) {
				$("#targetHolder .target:eq(" + i + ")").droppable({
					accept:	(!this.isTracked && (x_currentPageXML.getAttribute("markEnd") == undefined || x_currentPageXML.getAttribute("markEnd") == "false")) ?
						$("#labelHolder .label").filter(function() {
							return $(this).data("answer") == $("#targetHolder .target:eq(" + i + ")").data("answer");
						}) : $("#labelHolder .label")
				});
			}

			// customise the appearance of hotpots via styles & determine whether the styling is kept after label is dropped
			$("#targetHolder").addClass(x_currentPageXML.getAttribute("gapLook") == null ? "bg" : x_currentPageXML.getAttribute("gapLook"));
			$("#targetHolder").addClass(x_currentPageXML.getAttribute("gapLookFilled") == null ? "gapStyle_false" : "gapStyle_" + x_currentPageXML.getAttribute("gapLookFilled"));

			// keep track of the initial position of the labels within the labelHolder div
			// this is used later to force labels to be roughly over targets they are dropped on when moved using keyboard (done automatically when dragged with mouse)
			$("#dragDropHolder .label").each(function() {
				$(this).data({
					"leftOffset": $(this).position().left + parseInt($(this).css("margin-left")),
					"topOffset": $(this).position().top + parseInt($(this).css("margin-top")),
				});
			});
		}

		// drag drop mode: label dropped on target - by mouse or keyboard
		this.dropLabel = function($thisTarget, $thisLabel) {
			// remove feedback text
			$feedbackTxt.find('#txt').html("");

			// nothing should be currently selected
			$("#dragDropHolder .selected").removeClass("selected");
			$pageContents.data("selectedLabel", "");

			// the label was previously on a target
			if ($thisLabel.data("prevHolder")) {
				let prevHolder = $thisLabel.data("prevHolder");
				if ($("#targetHolder").data("compress") == true) {
					prevHolder.width(prevHolder.data("width"));
				}
				// re-enable previous target
				prevHolder
						.html("")
						.droppable("option", "disabled", false)
						.addClass("highlight")
						.remove("ui-droppable-disabled")
						.attr("tabindex", "0");

				gapFill.setUpTargetListeners(prevHolder);

				// sort any score changes caused by removing from previous target
				if (this.isTracked || x_currentPageXML.getAttribute("markEnd") == "true") {
					if ($thisLabel.data("answer") == prevHolder.data("answer")) {
						score--;
						$thisLabel.add(prevHolder).data("correct", false);
					}
				} else {
					prevHolder.removeClass("correct");
					if ($thisLabel.data("answer") == prevHolder.data("answer")) {
						score--;
						$thisLabel.add(prevHolder).data("correct", false);
					}
				}
				delete labelAnswers[prevHolder.data("answer")];
			}

			// label might have been dragged onto a target in the gap fill text
			// or back to the target holder
			if (!$thisTarget.is($("#labelHolder"))) {
				// on a target in gap fill text
				$thisLabel
						.data("dragged", true)
						.css("opacity", 0);

				// sort any score changes caused by moving to current target
				if (this.isTracked || x_currentPageXML.getAttribute("markEnd") == "true") {
					if ($thisLabel.data("answer") == $thisTarget.data("answer")) {
						score++;
						$thisLabel.add($thisTarget).data("correct", true);
					}
				} else {
					$thisTarget.addClass("correct");
					if ($thisLabel.data("answer") == $thisTarget.data("answer")) {
						score++;
						$thisLabel.add($thisTarget).data("correct", true);
					}
				}

				// this ensures that MathJax isn't duplicated next time x_pageContentsUpdated()
				var $labelClone = $thisLabel.clone();
				$labelClone.find("script[id^='MathJax-Element']").remove();

				// disable the target from receiving a new label
				$thisTarget
						.off("focusin focusout") // don't disable click so users can still move label off target
						.droppable("option", "disabled", true)
						.removeClass("highlightDark ui-state-disabled")
						.html($labelClone.html()).find(".sr-only").remove();

				// appearance of gap is maintained even after label has been dropped
				if ($("#targetHolder").hasClass("gapStyle_false")) {
					$thisTarget.removeClass("highlight");
				}
				if ($thisTarget.data("width") != undefined) {
					$thisTarget.width("auto");
				}

				// keep hidden label over target so it can be dragged off again if required
				$thisLabel.css({
					top: $thisTarget.position().top - $thisLabel.data("topOffset"),
					left: $thisTarget.position().left - $thisLabel.data("leftOffset")
				});

				if(x_currentPageXML.getAttribute("markEnd") == "true" || this.isTracked) {
					// prevent label from being tabbed to while hidden
					$thisLabel.data("prevHolder", $thisTarget);
					$thisLabel.removeAttr("tabindex");
				} else {
					// label can only be dropped to correct target so disable it completely
					$thisLabel.draggable("disable").off("keypress focusin focusout click").removeAttr("aria-label tabindex");
					$thisTarget
						.off("keypress").removeAttr("tabindex aria-label")
						.append('<span class="sr-only"> ' + gapFill.tickTxt + '</span>');
				}

				labelAnswers[$thisTarget.data("answer")] = $thisLabel.data("answer");

				// if marking is done immediately (so can only drop on correct targets), show feedback immediately when all labels have been placed
				if (!this.isTracked && (x_currentPageXML.getAttribute("markEnd") != "true" && $targetHolder.find(".target:not(.ui-droppable-disabled)").length == 0)) {
					$("#labelHolder").hide();
					$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
					gapFill.audioFbResize(true);
					gapFill.dragDropSubmit();
					x_pageContentsUpdated();
				}

			} else {
				// back on the target holder
				// reset the label so it's ready to be dragged again
				$thisLabel
					.data({
						"dragged": false,
						"prevHolder": null
					})
					.css({
						"opacity": 1,
						"left": 0,
						"top": 0
					})
					.attr("tabindex", "0");
			}

			// ensure all dropped labels are still in correct position over targets
			this.dragDropPosition();
		}
		
		// drag drop mode: set up events on targets used when keyboard rather than mouse is used
		this.setUpTargetListeners = function($targets) {
			$targets
				.focusin(targetFocusIn)
				.focusout(targetFocusOut)
				.keypress(targetKeyPress)
				.click(targetClick);
		}

		// drag drop mode: add highlight style when focused
		var targetFocusIn = function(e) {
			var $this = $(this);
			$this.addClass("highlightDark");
		}

		// drag drop mode: remove highlight style when focus removed
		var targetFocusOut = function(e) {
			var $this = $(this);
			$this.removeClass("highlightDark");
		}

		// drag drop mode: trigger click when in focus and space bar pressed
		var targetKeyPress = function(e) {
			var charCode = e.charCode || e.keyCode;
			if (charCode == 32) {
				const $this = $(this);
				if($this.hasClass("ui-droppable-disabled")) {
					$("#labelHolder .label").each(function(){
						if ($(this).data("dragged") == true && $(this).data("prevHolder").is($this)) {
							$(this).click();
							return false;
						}
					});
				} else {
					$(this).click();
				}
			}
		}

		// drag drop mode: drop selected label on target
		var targetClick = function() {
			var $selectedLabel = $pageContents.data("selectedLabel");
			if ($selectedLabel != undefined && $selectedLabel != "") {
				const $tempLabel = $selectedLabel.clone();
				$tempLabel.find(".sr-only").remove();
				if ($(this).is($("#labelHolder")) || answerData[$(this).data("index")].indexOf($tempLabel.html()) != -1 || (x_currentPageXML.getAttribute("markEnd") != undefined && x_currentPageXML.getAttribute("markEnd") != "false") || gapFill.isTracked) {
					// drop label: either because mark at end is on so labels can be dropped on any target or target is correct one
					gapFill.dropLabel($(this), $selectedLabel);

				} else {
					// mark at end is off so labels can only be dropped on correct targets - return label to targetHolder
					$selectedLabel
							.removeClass("selected")
							.removeAttr("aria-label");
					$pageContents.data("selectedLabel", "");

					// show try again text
					if (x_currentPageXML.getAttribute("tryAgain") != undefined && x_currentPageXML.getAttribute("tryAgain") != "") {
						$("#tryAgain").html('<p>'+x_currentPageXML.getAttribute("tryAgain")+'</p>');
					}
				}
			}
		}
		
		// drag drop mode: set up events on labels used when keyboard rather than mouse is used
		this.setUpLabelListeners = function($labels) {
			$labels
				.focusin(labelFocusIn)
				.focusout(labelFocusOut)
				.keypress(labelKeyPress)
				.click(labelClick);
		}

		// drag drop mode: add style when focused
		var labelFocusIn = function(e) {
			e.stopPropagation();
			var $this = $(this);
			if ($this.is($pageContents.data("selectedLabel")) == false) {
				$this.addClass("focus");
			}
		}

		// drag drop mode: remove style when focus removed
		var labelFocusOut = function(e) {
			e.stopPropagation();
			var $this = $(this);
			$this.removeClass("focus");
		}

		// drag drop mode: trigger click when in focus and space bar pressed
		var labelKeyPress = function(e) {
			e.stopPropagation();
			var charCode = e.charCode || e.keyCode;
			if (charCode == 32) {
				$(this).click();
			}
		};

		// drag drop mode: select label ready to be moved to a target
		var labelClick = function(e) {
			e.stopPropagation();

			// clear any feedback text
			$("#tryAgain").empty();

			// remove any existing selected styles & aria-labels that say other labels are selected
			$("#dragDropHolder .selected").removeClass("selected");

			if ($pageContents.data("selectedLabel") != undefined && $pageContents.data("selectedLabel") != "") {
				$pageContents.data("selectedLabel").removeAttr("aria-label");
			}

			// select the label
			var $this = $(this);
			$this
				.removeClass("focus")
				.addClass("selected")
				.attr("aria-label", labelTxt);

			$pageContents.data("selectedLabel", $this);

			// if the label is already on a target, add the selected style to the target as the label will be hidden
			if ($this.data("prevHolder")) {
				$this.data("prevHolder").addClass("selected");
			}
		}

		// drop down mode: submit answers - either because submit button clicked or on leaving the page
		this.dropDownSubmit = function(forced) {
			$feedbackTxt.find("#txt").html("");

			// no answers given
			if ($targetHolder.find('select option:selected[value=" "]').parent().length == $targetHolder.find('select').length) {
				// prompt to complete exercise unless this has been triggered by leaving the page
				if (forced != true) {
					$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillIncomplete") != undefined && x_currentPageXML.getAttribute("gapFillIncomplete") != "" ? x_currentPageXML.getAttribute("gapFillIncomplete") : "Please complete the exercise.") + '</p>');
					x_pageContentsUpdated();
				}
				
			// an attempt (even if partial) has been made
			} else {
				// mark exercise (unless force tracking mode is on & exercise is incomplete)
				if ($targetHolder.find('select option:selected[value=" "]').parent().length == 0 || !this.isTracked) {
					var wrong = 0,
						correct,
						result,
						answer,
						answers,
						options;

					total = 0;
					correct_answers = 0;

					// mark each combo box
					$targetHolder.find("select").each(function(i) {
						var $this = $(this);
						answers = [];
						options = [];
						answer = $this.val();
						total++;
						
						if ($.inArray($this.val(), answerData[i]) != -1) {
							// correct answer
							if (!$this.hasClass("correct")) {
								$this
									.attr("disabled", "disabled")
									.addClass('correct')
									.before('<span class="sr-only"> ' + gapFill.tickTxt + ': </span>');
							}

							correct = true;
							correct_answers++;

						} else {
							// incorrect answer
							wrong++;
							correct = false;

							// only one attempt allowed if tracking on - prevent further attempts
							if (gapFill.isTracked) {
								$this
									.attr("disabled", "disabled")
									.addClass('incorrect')
									.before('<span class="sr-only"> ' + gapFill.crossTxt + ': </span>');
							}
						}

						// collect scores & question/option data
						answers.push(answer);
						result = {
							success: correct,
							score: (correct ? 100.0 : 0.0)
						};
						$this.find(":selected").each(function(j) {
							$this = $(this);
							options.push({
								id: $.inArray($this.val(), allDropDownAnswers[i]) + 1 + "",
								answer: $this.val(),
								result: ($.inArray($this.val(), answerData[i]) != -1)
							});
						});
						
						XTExitInteraction(x_currentPage, i, result, options, answers, [], x_currentPageXML.getAttribute("trackinglabel"));
					});

					gapFill.finishTracking();

					if (wrong == 0) {
						// all correct - show feedback & hide buttons
						$("#submitBtn, #showBtn").hide();
						$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
						gapFill.audioFbResize(true);
						x_pageContentsUpdated();
						finished = true;
						
					} else {
						// one or more incorrect answers
						if (x_currentPageXML.getAttribute("showHint") != "false") {
							// show the show answers button if required
							$targetHolder.find("select").each(function() {
								if ($(this).val() != " ") {
									attempts++;
									if (attempts >= (x_currentPageXML.getAttribute("attemptsBeforeHint") != undefined && $.isNumeric(x_currentPageXML.getAttribute("attemptsBeforeHint")) ? Number(x_currentPageXML.getAttribute("attemptsBeforeHint")) : 2)) {
										$("#showBtn").show();
									}
									return false;
								}
							});
						}
						
						// show feedback - might be different if tracking on/off
						var gapFillWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillWrong") != undefined && x_currentPageXML.getAttribute("gapFillWrong") != "" ? x_currentPageXML.getAttribute("gapFillWrong") : "You have not filled any gaps correctly. Try again."),
							gapFillPartWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillPartWrong") != undefined && x_currentPageXML.getAttribute("gapFillPartWrong") != "" ? x_currentPageXML.getAttribute("gapFillPartWrong") : "Your correct answers are shown in green. Try again with those you have got wrong.");
						
						if (this.isTracked) {
							gapFillWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillWrongTracking") != undefined && x_currentPageXML.getAttribute("gapFillWrongTracking") != "" ? x_currentPageXML.getAttribute("gapFillWrongTracking") : "You have not filled any gaps correctly.");
							gapFillPartWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillPartWrongTracking") != undefined && x_currentPageXML.getAttribute("gapFillPartWrongTracking") != "" ? x_currentPageXML.getAttribute("gapFillPartWrongTracking") : "Your correct answers are shown in green.");

							$("#submitBtn").hide();
							$("#showBtn").show();
							finished = true;
						}
						
						if (wrong == $targetHolder.find("select").length) {
							$("#feedbackTxt #txt").html('<p>' + gapFillWrong + '</p>');
						} else {
							$("#feedbackTxt #txt").html('<p>' + gapFillPartWrong + '</p>');
						}
						x_pageContentsUpdated();
					}
					
				// if force tracking mode is on then you must fully complete before checking answers
				} else {
					// prompt to complete exercise
					$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillIncomplete") != undefined && x_currentPageXML.getAttribute("gapFillIncomplete") != "" ? x_currentPageXML.getAttribute("gapFillIncomplete") : "Please complete the exercise.") + '</p>');
					x_pageContentsUpdated();
				}
			}
        };

		// fill blank mode: submit answers - either because submit button clicked or on leaving the page
		this.fillInSubmit = function(forced) {
			let judge = true;
			if(x_currentPageXML.getAttribute("judge") === 'false') {
				judge = false;
			}

			// no answers submitted
			if ($targetHolder.find("input").filter(function() { return $(this).val() != ""; }).length == 0) {
				// prompt to complete exercise unless this has been triggered by leaving the page
				if (forced != true) {
					$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillIncomplete") != undefined && x_currentPageXML.getAttribute("gapFillIncomplete") != "" ? x_currentPageXML.getAttribute("gapFillIncomplete") : "Please complete the exercise.") + '</p>');
					x_pageContentsUpdated();
				}
				
			// an attempt (even if partial) has been made
			} else if (x_currentPageXML.getAttribute("markEnd") == "true" || this.isTracked || !judge) {
				// mark exercise (unless force tracking mode is on & exercise is incomplete)
				if ($targetHolder.find("input").filter(function() { return $(this).val() == ""; }).length == 0 || !this.isTracked) {
					// show the 'show answers' button if correct no. attempts have been made
					if (x_currentPageXML.getAttribute("showHint") != "false" && judge) {
						attempts++;
						if (attempts >= (x_currentPageXML.getAttribute("attemptsBeforeHint") != undefined && $.isNumeric(x_currentPageXML.getAttribute("attemptsBeforeHint")) ? Number(x_currentPageXML.getAttribute("attemptsBeforeHint")) : 2)) {
							$("#showBtn").show();
						}
					}
					
					var wrong = 0;
					total = 0;
					correct_answers = 0;

					$targetHolder.find("input").each(function() {
						var $this = $(this),
							currvalue = !casesensitive ? $this.val().trim().toLowerCase() : $this.val().trim();
						var feedback = "Incorrect";
						var correct = false;
						var answer = currvalue;

						if (judge) {
							$this.addClass("judged");
						}

						// correct answer entered (or it's not being judged)
						if ((answerData.length > 0 && answerData[$this.data("index")].indexOf(currvalue) != -1) || !judge) {
							if (!$this.hasClass("correct")) {
								$this.removeAttr("incorrect");

								if (judge) {
									$this
										.attr({
											"correct": "correct",
											"readonly": "readonly",
											"disabled": "true"
										})
										.addClass("correct")
										.before('<span class="sr-only"> ' + gapFill.tickTxt + '</span>');
								}
							}

							feedback = "Correct";
							correct = true;
							correct_answers++;

						// incorrect answer entered
						} else {
							$this.attr("incorrect", "incorrect");
							wrong++;

							// only one attempt allowed if being tracked
							if (gapFill.isTracked) {
								$this
									.attr({
										"readonly": "readonly",
										"disabled": "true"
									})
									.addClass("incorrect")
									.before('<span class="sr-only"> ' + gapFill.crossTxt + '</span>');
							}
						}

						total++;
						var result = {
							success: correct,
							score: (correct ? 100.0 : 0.0),
							judge: judge
						};
						
						XTExitInteraction(x_currentPage, $this.data("index") , result, [], answer, feedback, x_currentPageXML.getAttribute("trackinglabel"));
					});

					gapFill.finishTracking();
					
					// show feedback - might be different if tracking on/off
					var gapFillWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillWrong") != undefined && x_currentPageXML.getAttribute("gapFillWrong") != "" ? x_currentPageXML.getAttribute("gapFillWrong") : "You have not filled any gaps correctly. Try again."),
						gapFillPartWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillPartWrong") != undefined && x_currentPageXML.getAttribute("gapFillPartWrong") != "" ? x_currentPageXML.getAttribute("gapFillPartWrong") : "Your correct answers are shown in green. Try again with those you have got wrong.");
					
					if (this.isTracked) {
						gapFillWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillWrongTracking") != undefined && x_currentPageXML.getAttribute("gapFillWrongTracking") != "" ? x_currentPageXML.getAttribute("gapFillWrongTracking") : "You have not filled any gaps correctly.");
						gapFillPartWrong = x_addLineBreaks(x_currentPageXML.getAttribute("gapFillPartWrongTracking") != undefined && x_currentPageXML.getAttribute("gapFillPartWrongTracking") != "" ? x_currentPageXML.getAttribute("gapFillPartWrongTracking") : "Your correct answers are shown in green.");
						
						finished = true;
					}

					// all correct - show final feedback & hide buttons
					if (wrong == 0) {
						$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
						gapFill.audioFbResize(true);
						x_pageContentsUpdated();

						if (judge) {
							$("#showBtn, #submitBtn").hide();
						}

						if (judge) {
							finished = true;
						}

					// one or more incorrect answers submitted - give appropriate feedback
					} else {
						if (wrong == $targetHolder.find("input").length) {
							$("#feedbackTxt #txt").html('<p>' + gapFillWrong + '</p>');
						} else {
							$("#feedbackTxt #txt").html('<p>' + gapFillPartWrong + '</p>');
						}
						x_pageContentsUpdated();

						// only one attempt allowed if being tracked
						if (this.isTracked) {
							$("#submitBtn").hide();
							$("#showBtn").show();
						}
					}
				
				// if force tracking mode is on then you must fully complete before checking answers
				} else {
					$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillIncomplete") != undefined && x_currentPageXML.getAttribute("gapFillIncomplete") != "" ? x_currentPageXML.getAttribute("gapFillIncomplete") : "Please complete the exercise.") + '</p>');
					x_pageContentsUpdated();
				}
			}
		};

		// drag drop mode: submit answers - either because submit button clicked or marking is done immediately & all labels placed correctly
		this.dragDropSubmit = function(forced) {
			
			// no labels placed in targets
			if ($targetHolder.find(".target.ui-droppable-disabled").length == 0) {
				// prompt to complete exercise unless this has been triggered by leaving the page
				if (forced != true) {
					$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillIncomplete") != undefined && x_currentPageXML.getAttribute("gapFillIncomplete") != "" ? x_currentPageXML.getAttribute("gapFillIncomplete") : "Please complete the exercise.") + '</p>');
					x_pageContentsUpdated();
				}
				
			// an attempt (even if partial) has been made
			} else {
				// mark exercise (unless force tracking mode is on & exercise is incomplete)
				if ($targetHolder.find(".target:not(.ui-droppable-disabled)").length == 0 || !this.isTracked) {
					// add correct styling & ticks to correctly filled targets
					$("#targetHolder .target").filter(function () { return $(this).data("correct") == true && !$(this).hasClass("correct"); })
						.addClass("correct")
						.removeClass("highlightDark")
						.off("keypress focusin focusout click")
						.removeAttr("tabindex aria-label")
						.append('<span class="sr-only"> ' + gapFill.tickTxt + '</span>');

					// disable correctly dropped labels so they can't be moved
					$("#labelHolder .label").filter(function () { return $(this).data("correct") == true; })
						.draggable("disable")
						.off("keypress focusin focusout click")
						.removeAttr("aria-label tabindex");

					// populate arrays of incorrectly filled or placed targets & labels
					var $incorrectTargets = $("#targetHolder .target").filter(function () {
						return !($(this).data("correct") == true || $(this).hasClass("correct")) && $(this).hasClass("ui-droppable-disabled");
					});
					var $incorrectLabels = $("#labelHolder .label").filter(function () {
						return $(this).data("correct") != true;
					});
					
					// track before moving back labels or else results page looks like you haven't attempted to answer
					var l_options = [];
					var l_answers = [];
					var feedback = "Correct";
					total = 0;
					correct_answers = 0;
					for (var interactionNumber = 0; interactionNumber < answerData.length; interactionNumber++) {
           				var correctAnswer = answerData[interactionNumber][0];
						var labelSource = labelAnswers[correctAnswer] == undefined ? " " : labelAnswers[correctAnswer];
						var option = {source: labelSource, target: interactionNumber+''};
						l_options.push(option);
						if (correctAnswer == labelSource) {
							correct_answers++;
						}

						var l_answer = labelSource + "-->" + interactionNumber;
						l_answers.push(l_answer);
						total++;
					}
					const correct = (total == correct_answers);
					const result = {
						success: correct,
						score: (correct_answers * 100.0)/total
					};
					if (!correct) { feedback = "Incorrect"; }
					XTExitInteraction(x_currentPage, 0, result, l_options, l_answers, feedback);
					gapFill.finishTracking();
					
					if (!this.isTracked) {
						// not tracked - reset incorrect labels/targets so you can try again
						$incorrectTargets.each(function() {
							if ($(this).data("width") != undefined) {
								$(this).width($(this).data("width"));
							}
						});

						$incorrectTargets
							.html("")
							.droppable("option", "disabled", false)
							.addClass("highlight")
							.attr("tabindex", "0");

						gapFill.setUpTargetListeners($incorrectTargets);

						// clear text from incorrect targets
						$incorrectTargets.each(function() {
							delete labelAnswers[$(this).data("answer")];
						});

						$incorrectLabels
							.draggable("option", "disabled", false)
							.data({
								"prevHolder": null,
								"dragged": false
							})
							.css({
								"opacity": 1,
								"left": "auto",
								"top": "auto"
							})
							.attr("tabindex", "0");

						this.setUpLabelListeners($incorrectLabels);

						if ($targetHolder.find(".target:not(.ui-droppable-disabled)").length == 0) {
							// complete - hide buttons
							$("#submitBtn, #showBtn").hide();

						} else if (x_currentPageXML.getAttribute("showHint") != "false") {
							// show the 'show answers' button if correct no. attempts have been made
							attempts++;
							if (attempts >= (x_currentPageXML.getAttribute("attemptsBeforeHint") != undefined && $.isNumeric(x_currentPageXML.getAttribute("attemptsBeforeHint")) ? Number(x_currentPageXML.getAttribute("attemptsBeforeHint")) : 2)) {
								$("#showBtn").show();
							}
						}
						
					} else {
						// if tracked then you don't get to try again
						$incorrectTargets
							.addClass("incorrect")
							.off("keypress")
							.removeAttr("tabindex aria-label")
							.append('<span class="sr-only"> ' + gapFill.crossTxt + '</span>');

						$("#labelHolder, #submitBtn").hide();
						finished = true;

						// show the 'show answers' button if not all answers are correct
						if (correct !== true) {
							$("#showBtn").show();
						}
					}

					// show feedback
					if (score == $("#targetHolder .target").length) {
						// all correct
						$("#labelHolder").hide();
						$("#feedbackTxt #txt").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
						x_pageContentsUpdated();
						gapFill.audioFbResize(true);
						finished = true;
					} else {
						if (score == 0) {
							// none correct
							$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillWrongTracking") != undefined && x_currentPageXML.getAttribute("gapFillWrongTracking") != "" ? x_currentPageXML.getAttribute("gapFillWrongTracking") : "You have not filled any gaps correctly.") + '</p>');
						} else {
							// partially correct
							$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillPartWrongTracking") != undefined && x_currentPageXML.getAttribute("gapFillPartWrongTracking") != "" ? x_currentPageXML.getAttribute("gapFillPartWrongTracking") : "Your correct answers are shown in green.") + '</p>');
						}
						x_pageContentsUpdated();
					}

				// if force tracking mode is on then you must fully complete before checking answers
				} else {
					// prompt to complete exercise
					$("#feedbackTxt #txt").html('<p>' + x_addLineBreaks(x_currentPageXML.getAttribute("gapFillIncomplete") != undefined && x_currentPageXML.getAttribute("gapFillIncomplete") != "" ? x_currentPageXML.getAttribute("gapFillIncomplete") : "Please complete the exercise.") + '</p>');
					x_pageContentsUpdated();
				}
			}
		}

		// drag drop mode: ensure labels on targets are in correct position even though hidden
		// this is important so they can be dragged off targets if needed
		this.dragDropPosition = function() {
			if (x_currentPageXML.getAttribute("markEnd") == "true" || this.isTracked) {
				// update initial position of the labels within the labelHolder div
				$("#labelHolder .label").each(function() {
					const $thisLabel = $(this);

					// these labels are on a target (not visible) - reset position to default so offset can be correctly calculated
					if ($thisLabel.data("dragged") === true) {
						$thisLabel.css({
							top: "auto",
							left: "auto"
						});
					}

					// get updated default position for all labels
					$thisLabel.data({
						"leftOffset": $thisLabel.position().left + parseInt($thisLabel.css("margin-left")),
						"topOffset": $thisLabel.position().top + parseInt($thisLabel.css("margin-top")),
					});

					// now position the labels that are on targets so they are roughly in correct position
					if ($thisLabel.data("dragged") === true) {
						const $thisTarget = $thisLabel.data("prevHolder");
						$thisLabel.css({
							top: $thisTarget.position().top - $thisLabel.data("topOffset"),
							left: $thisTarget.position().left - $thisLabel.data("leftOffset")
						});
					}
				});
			}
		}

		// Starting the tracking
		this.initTracking = function() {
			// Track the gapfill page
			this.weighting = 1.0;
			// fill blank is only mode that allows for no judging of answers
			if (x_currentPageXML.getAttribute("interactivity") == "Fill in Blank" && x_currentPageXML.getAttribute("judge") === 'false') {
				this.weighting = 0.0;
			} else if (x_currentPageXML.getAttribute("trackingWeight") != undefined) {
				this.weighting = x_currentPageXML.getAttribute("trackingWeight");
			}

			if (x_currentPageXML.getAttribute("interactivity") !== "Drag Drop")  // text fill in blank or drop down
			{
                XTSetPageType(x_currentPage, 'numeric', answerData.length, this.weighting);
			}
			else { // drag & drop
                XTSetPageType(x_currentPage, 'numeric', 1, this.weighting);
            }
		}
		
		// Stopping the tracking
		this.finishTracking = function() {
			if(total != 0)
			{
				XTSetPageScore(x_currentPage, ((correct_answers * 100.0)/total), x_currentPageXML.getAttribute("trackinglabel"));
			}
			else
			{
				XTSetPageScore(x_currentPage, 0.0, x_currentPageXML.getAttribute("trackinglabel"));
			}
		}
	}
	
	gapFill.init();
	
</script>


<div id="pageContents">
	
	<div class="splitScreen">
		
		<div id="textHolder" class="left">
			<div id="mainText"></div>
		</div>
		
		<div id="dragDropHolder" class="right">
			<div id="mainPanel" class="panel">
				<div id="targetHolder"></div>
				<div id="labelHolder"></div>
				<div id="btnHolder">
					<button id="showBtn"></button>
					<button id="submitBtn"></button>
				</div>
				<div id="feedbackTxt">
					<div id="txt" aria-live="polite"></div>
					<div id="audioHolder"></div>
				</div>
			</div>
		</div>
		
	</div>
	
</div>
