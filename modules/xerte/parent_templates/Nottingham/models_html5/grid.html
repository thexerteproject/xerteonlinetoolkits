<script type="text/javascript">
/**
 * Licensed to The Apereo Foundation under one or more contributor license
 * agreements. See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.

 * The Apereo Foundation licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except in
 * compliance with the License. You may obtain a copy of the License at:
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.

 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
	// pageChanged & sizeChanged functions are needed in every model file
	// other functions for model should also be in here to avoid conflicts
	var grid = new function() {
		var fixedRows = [],
			fixedCols = [],
			fixedCells = [],
			timeout,
			labelData = [],
			separator = "|",
			$pageContents,
            checked = false;
		var numOfQuestions = 0, correct = 0;

		// function called every time the page is viewed after it has initially loaded
		this.pageChanged = function() {
			labelData = $("#pageContents").data("labelData");
			$pageContents = $("#pageContents");
			$("#checkBtn").show();
			$(".ui-draggable").draggable("enable");
			this.removeFocus();
		}

		// function called every time the size of the LO is changed
		this.sizeChanged = function() {
			var $grid = $("#grid");
			var data = x_currentPageXML.getAttribute("data").split("||");
			this.addLabelRefresh(data)

			row = data[0].split(separator);
			$("#content").css({
				'width': ""
			})

			var colWidth = $("#pageContents").width() - $("#otherContent").width();
			if(x_currentPageXML.getAttribute("align") == "top"){
				colWidth =  $("#pageContents").width()
			}
			colWidth = colWidth - (colWidth/row.length);
			colWidth = colWidth/row.length;
			/*
			if(fixedCols.length>0){
				colWidth = colWidth/(row.length-1);
			}else{
				colWidth = colWidth/row.length;
			}
			*/
			var column;

			$grid.css('width', colWidth)

			//$(".listHolder ul:not(:first)").css('width', colWidth)

			$("ul[class!='preview']")
				.css("width", "")
				.css("height", "")
				.find("li")
					.css("width", "")
					.css("height", "");

			$("#gridHolder")
				.css("width", "")
				.css("height", "");
			$("#gridBorders")
				.css("width", "")
				.css("height", "");
			if (x_currentPageXML.getAttribute("constrain") == "col") {
				var column = 0;
				var maxW, maxH = 0;

				var rowsWidth = [];

				$grid.find("ul[class!='preview']").each(function() {
					maxW = 0;
					$(this).find("li").each(function(i) {
						maxW = Math.max(maxW, $(this).width());
						if ($.inArray(i,fixedRows) == -1) {
							maxH = Math.max(maxH, $(this).height());
						}
					}).width(maxW + 5 + "px");
					rowsWidth.push(maxW)
					column += maxW+5;
				}).find("li")
						.height(maxH + "px");
				$grid.find("ul[class='preview']").each(function(i) {
					const maxW = rowsWidth[i];
					$(this).find("li").width(maxW + 5 + "px")
				});



				// ...unless they're in a fixed row when they must just have same height as other labels on that row
				for (i=0; i<fixedRows.length; i++) {
					maxH = 0;
					$grid.find("ul[class!='preview'] li.static").each(function() {
						if ($(this).data("xy")[1] == fixedRows[i]) {
							$(this).css("height", "");
							maxH = Math.max(maxH, $(this).height());
						}
					});
					$grid.find("ul[class!='preview'] li.static").each(function() {
						if ($(this).data("xy")[1] == fixedRows[i]) {
							$(this).css("height", maxH);
						}
					});
				}

			} else if (x_currentPageXML.getAttribute("constrain") == "row") {
				// labels on each row should be same height & all labels should be same width...
				var maxW = 0, maxH;
				$grid.find("ul[class!='preview']").each(function() {
					maxH = 0;
					$(this).find("li").each(function(i) {
						maxH = Math.max(maxH, $(this).height());
						if ($.inArray(i,fixedCols) == -1) {
							maxW = Math.max(maxW, $(this).width());
						}
						/*if(maxW > ($grid.width()-24)){
							maxW = $grid.width()-24;
						}*/
					}).height(maxH + "px");
				}).find("li")
						.width(maxW + 5 + "px");
				$grid.find("ul[class='preview']").find("li").width(maxW + 5 + "px");

				column = maxW+5;
				// ...unless they're in a fixed column when they must just have same width as other labels on that column
				for (i=0; i<fixedCols.length; i++) {
					maxW = 0;
					$grid.find("ul").find("li:eq(" + fixedCols[i] + ")").each(function() {
						$(this).css("width", "");
						maxW = Math.max(maxW, $(this).width());
					}).width(maxW + 5 + "px");
				}

			}else{
				// every label should be same width & height...
				var maxW = 0, maxH = 0;
				$grid.find("ul li").each(function(i) {
					if ($.inArray($(this).data("xy")[0],fixedCols) == -1) {
						maxW = Math.max(maxW, $(this).width());
					}
					if ($.inArray(i,fixedRows) == -1) {
						maxH = Math.max(maxH, $(this).height());
					}
				})
						.width(maxW + 5 + "px")
						.height(maxH + "px");

				column = maxW+5;

				// ...unless they're in a fixed column/row when they must just have same width/height as other labels on that column/row
				for (var i=0; i<fixedCols.length; i++) {
					maxW = 0;
					var $labels = $([]);
					$grid.find("ul li.static").each(function() {
						if ($(this).data("xy")[0] == fixedCols[i]) {
							$(this).css("width", "");
							maxW = Math.max(maxW, $(this).width());
							if ($labels == undefined) { $labels = $(this); } else { $labels = $labels.add($(this));}
						}
					});
					$labels.width(maxW + 5 + "px");
				}

				for (var i=0; i<fixedRows.length; i++) {
					maxH = 0;
					var $labels = $([]);
					$grid.find("ul li.static").each(function() {
						if ($(this).data("xy")[1] == fixedRows[i]) {
							$(this).css("height", "");
							maxH = Math.max(maxH, $(this).height());
							if ($labels == undefined) { $labels = $(this) } else { $labels = $labels.add($(this)); }
						}
					});
					$labels.height(maxH);
				}
			}

			var gridWidth;
			if(x_currentPageXML.getAttribute("constrain") != "col"){
				if(fixedCols.length>0){
					//gridWidth = column * (row.length-1) + maxW + 5 + (24*row.length);
					gridWidth = column * (row.length-1) + maxW + 5 + (23.2*row.length);
				}else{
					//gridWidth = column * (row.length) + maxW + 5 + (24*row.length);
					gridWidth = column * (row.length) + (23.2*row.length);
				}
				$(".listHolder ul:first").css('width', gridWidth);
				$(".listHolder ul:not(:first)").css('width', gridWidth);
			}else{
				if(fixedCols.length>0){
					gridWidth = column + (24*row.length);
				}else{
					gridWidth = column + (24*row.length);
				}
				$grid.css('width', gridWidth);
			}
			// limit #otherContent to what is left when alignment is right
			const align = x_currentPageXML.getAttribute('align');
			if (align == 'right') {
				$('#otherContent').css('width', $('#pageContents').width() - $grid.width());
			}

			$("#gridBorders").css('width', gridWidth);

			$("#gridHolder")
					.width($grid.width())
					.height($grid.height());

			if (align == 'top')
			{
				$("#gridHolder").css("margin", "10px auto auto");
			}

			var num = data[0].split(separator).length;

			$("#gridBorders").find("tr").each(function(i) {
				if(x_currentPageXML.getAttribute("constrain") == "col") {
					var $li = $grid.find("ul[class != 'preview']:eq(0) li:eq(" + i + ")")
					$(this).height($li.outerHeight(true) - 5);
				}else{
					var $li = $grid.find("ul[class != 'preview']:eq(" + i + ") li:eq(0)")
					$(this).height($li.outerHeight(true));
				}
			});


			$("#gridBorders").find("col").each(function(i) {
				if(x_currentPageXML.getAttribute("constrain") == "col"){
					$(this).width($grid.find("ul[class != 'preview']:eq("+i+") li:eq(0)").outerWidth(true));
				}else{
					$(this).width($grid.find("ul[class != 'preview']:eq(0) li:eq(" + i + ")").outerWidth(true));
				}

			});



		}

        this.leavePage = function()
        {
            if (!this.checked)
            {
                this.showFeedBackandTrackScore();
            }
        };

        this.showFeedBackandTrackScore = function()
        {
            // there are loads of variations on how we could mark this - at the moment it has to be in exact position (taking identical labels into account)
            // maybe at some point add an option to editor for how they want it marked (e.g. mark correct if in correct row but order in row irrelevant)
            var Correct = true,
                l_options = [],
                l_answers = [],
                l_feedbacks = [],
                l_answer,
                l_option,
                l_feedback,
                counter = 0;
                allCorrectLocal = true,
				judge = true;

			if(x_currentPageXML.getAttribute("judge") != undefined && x_currentPageXML.getAttribute("judge") == 'false'){
				judge = false;
			}
				
            $("#grid").find("ul:not(.preview) li:not(.static)").each(function() {
                Correct = true;
                var $this = $(this);
                var columnLength = x_currentPageXML.getAttribute("data").split("||")[0].split("|").length;
                var xPos = ($this.index() % columnLength) + 1;
                var yPos = (Math.floor($this.index() / columnLength)) + 1;
                l_answer = ($this.text().trim() + " --> [" + yPos + "," + xPos + "]");
                l_option = {source: $this.text().trim(),target: "[" + xPos + "," + yPos + "]"};
				
                if ($this.data("correct") == $this.index() || labelData[$("#grid .listHolder").index($this.parents(".listHolder"))][$this.index()] == $this.html() || !judge) {
					if(judge) {
						$this.append('<span class="tick"><span class="ui-helper-hidden-accessible"> ' + x_getLangInfo(x_languageData.find("tick")[0], "title", "Correct") + '</span><span class="result fa fa-fw fa-x-tick"></span></span>');
					}
                    numOfQuestions++;
                    correct++;
                    l_option.result = true;
                    l_feedback = "Correct";
                } else {
                    Correct = false;
					$this.append('<span class="tick"><span class="ui-helper-hidden-accessible"> ' + x_getLangInfo(x_languageData.find("cross")[0], "title", "Incorrect") + '</span><span class="result fa fa-fw fa-x-cross"></span></span>');
                    numOfQuestions++;
                    l_option.result = false;
                    l_feedback = "Incorrect";
                    allCorrectLocal = false;
                }
                l_options.push(l_option);
                l_answers.push(l_answer);
                l_feedbacks.push(l_feedback);
                counter++;
            });
			this.allCorrect = allCorrectLocal;
            var result = {
                success: this.allCorrect,
                score: ((correct/numOfQuestions)*100.0),
				judge: judge
            };

			this.checked = true;
            XTExitInteraction(x_currentPage, 0, result, l_options, l_answers, l_feedbacks, x_currentPageXML.getAttribute("trackinglabel"));


            if(XTGetMode() == "normal") {
                $("#checkBtn").hide();
                $(".ui-draggable").draggable("disable");
            }
            XTSetPageScore(x_currentPage, ((correct/numOfQuestions)*100.0), x_currentPageXML.getAttribute("trackinglabel"));
        };

		this.init = function() {
		    this.checked = false;
			$pageContents = $("#pageContents");

			$("#textHolder").html(x_addLineBreaks(x_currentPageXML.getAttribute("text")));
			if (!(x_currentPageXML.getAttribute("feedback") != undefined && x_currentPageXML.getAttribute("feedback") != "")) {
				$("#feedback").remove();
			}

			if (x_currentPageXML.getAttribute("align") == "top") {
				$("#gridHolder")
					.appendTo($pageContents)

				$("#feedback").appendTo($pageContents);
				$("#btnHolder").appendTo($pageContents);
			} else if (x_currentPageXML.getAttribute("align") == "right") {
				$("#gridHolder")
					.addClass("x_floatLeft")
			} else if (x_currentPageXML.getAttribute("align") == "left") {
				$("#gridHolder")
					.addClass("x_floatRight")
				$("#btnHolder").appendTo($pageContents)
			}


			var $grid = $("#grid");
			var $text = $("#otherContent");
			let gridSize = x_currentPageXML.getAttribute("gridSize");
			if (gridSize == undefined)
			{
				if (x_currentPageXML.getAttribute("text") == undefined)
				{
					gridSize = "full";
				}
				else {
					gridSize = "medium";
				}
			}
			if(gridSize == "small"){
				$text.css("max-width", "75%");
			}else if(gridSize == "large"){
				$text.css("max-width", "25%");
			}else if(gridSize == "full"){
				$text.remove()
			}else if (gridSize != "top"){
				$text.css("max-width", "50%");
			}

			var $content = $("#content");

			if(x_currentPageXML.getAttribute("align") == "left"){
				$content.css({
					"flex-direction":"row"
				})
			}else if(x_currentPageXML.getAttribute("align") == "right"){
				$content.css({
					"flex-direction": "row-reverse",
					"justify-content" : "space-between"
				})
			}else{
				$content.css("flex-direction", "column")
				$text.css("max-width", "100%");
			}

			$("#checkBtn")
				.button({label:	x_currentPageXML.getAttribute("checkBtnTxt") != undefined ? x_currentPageXML.getAttribute("checkBtnTxt") : "Check Answers"})
				.click(function() {
                    if ($(this).data("state") == "check") {
                        grid.removeFocus();
				        grid.showFeedBackandTrackScore();
                        if (grid.allCorrect == true) {
                            $(this)
                                .button({label: x_currentPageXML.getAttribute("resetBtnTxt") != undefined ? x_currentPageXML.getAttribute("resetBtnTxt") : "Reset"})
                                .data("state", "reset");

							if (x_currentPageXML.getAttribute("feedback") != undefined && x_currentPageXML.getAttribute("feedback") != "") {
								$("#feedback").html(x_addLineBreaks(x_currentPageXML.getAttribute("feedback")));
							}

                            $("#grid .listHolder ul li.ui-draggable")
                                .draggable( "option", "disabled", true )
                                .off("focusin focusout keypress click");
                        }
                    } else {
                        $(this)
                            .button({label:	x_currentPageXML.getAttribute("checkBtnTxt") != undefined ? x_currentPageXML.getAttribute("checkBtnTxt") : "Check Answers"})
                            .data("state", "check");

                        $("#feedback").empty();
                        $("#grid .tick").remove();
                        $("#grid .listHolder ul li.ui-draggable")
                            .draggable( "option", "disabled", false )
                            .on("focusin focusout keypress click");
                        grid.randomiseLabels();
                    }
                })
				.data("state", "check");

			if (x_currentPageXML.getAttribute("url") != undefined && x_currentPageXML.getAttribute("url") != "") {
				$.ajax({
					type: "GET",
					url: x_evalURL(x_currentPageXML.getAttribute("url")),
					dataType: "text",
					success: function(csv) {
						var csvData = csv.split("\r\n");
						if (csvData[csvData.length-1] == "") {
							csvData.splice(csvData.length-1, 1);
						}
						separator = ","
						grid.sortData(csvData);
					},
					error: function () {
						grid.sortData(x_currentPageXML.getAttribute("data").split("||"), false);
					}
				});
			} else {
				grid.sortData(x_currentPageXML.getAttribute("data").split("||"), false);
			}
			this.initTracking();
			// call this function in every model once everything has loaded
			this.sizeChanged();
			x_pageLoaded();
		}


		/*this.gridSize = function (size){
			var $grid = $("#grid"), $ul, $holder, row;
			var $text = $("#otherContent");
			var $content = $("#content");
			if(x_currentPageXML.getAttribute("gridSize") == "small"){
				$grid.width(size);
				$text.css("max-width", "75%");
			}else if(x_currentPageXML.getAttribute("gridSize") == "medium"){
				$grid.width(size * 2);
				$text.css("max-width", "50%");
			}else if(x_currentPageXML.getAttribute("gridSize") == "large"){
				$grid.width(size * 3);
				$text.css("max-width", "25%");
			}else{
				$text.remove()
			}


			if(x_currentPageXML.getAttribute("align") == "left"){
				$content.css("flex-direction", "row")
			}else if(x_currentPageXML.getAttribute("align") == "right"){
				$content.css("flex-direction", "row-reverse")
			}else{
				$content.css("flex-direction", "column")
			}
		}*/



		this.sortData = function(data) {

			var $grid = $("#grid"), $ul, $holder, row,
				$gridBorders = $("#gridBorders"), $tr;

			// rows, columns & individual labels can be fixed
			var tempR = x_currentPageXML.getAttribute("fixedRows") != undefined ? x_currentPageXML.getAttribute("fixedRows").split(",") : [],
				tempC = x_currentPageXML.getAttribute("fixedCols") != undefined ? x_currentPageXML.getAttribute("fixedCols").split(",") : [],
				tempCE = x_currentPageXML.getAttribute("fixedCells") ? x_currentPageXML.getAttribute("fixedCells").split("|") : [],
				i, j;

			for (i=0; i<tempR.length; i++) {
				if ($.isNumeric(tempR[i])) {
					fixedRows.push(Number(tempR[i]) - 1);
				}
			}

			if (x_currentPageXML.getAttribute("header") == "row" || x_currentPageXML.getAttribute("header") == "both") {
				$gridBorders.addClass("header");
				if ($.inArray(0, fixedRows) == -1) {
					fixedRows.push(0);
				}
			}

			for (i=0; i<tempC.length; i++) {
				if ($.isNumeric(tempC[i])) {
					fixedCols.push(Number(tempC[i]) - 1);
				}
			}

			if (x_currentPageXML.getAttribute("header") == "col" || x_currentPageXML.getAttribute("header") == "both") {
				$gridBorders.addClass("headerCol");
				if ($.inArray(0, fixedCols) == -1) {
					fixedCols.push(0);
				}
			}

			for (i=0; i<tempCE.length; i++) {
				var cells = tempCE[i].split(",");
				if (cells.length == 2) {
					if ($.isNumeric(cells[0]) && $.isNumeric(cells[1])) {
						fixedCells.push([Number(cells[0]) - 1, Number(cells[1]) - 1]);
					}
				}
			}

			// create labels - each label is a li with its parent ul determining which labels it can be sorted/swapped with
			// labels can be constrained to their row or column, or can be placed anywhere
			let gridSize = x_currentPageXML.getAttribute("gridSize");
			if (gridSize == undefined)
			{
				if (x_currentPageXML.getAttribute("text") == undefined)
				{
					gridSize = "full";
				}
				else {
					gridSize = "medium";
				}
			}
			row = data[0].split(separator);
			var colWidth = $("#pageContents").width() - $("#otherContent").width();
			const align = x_currentPageXML.getAttribute("align");
			switch(align)
			{
				case "top":
					colWidth =  $("#pageContents").width();
					break;
				case "left":
				case "right":
					switch (gridSize)
					{
						case "small":
							colWidth =  $("#pageContents").width() * 0.25;
							break;
						case "medium":
							colWidth =  $("#pageContents").width() * 0.5;
							break;
						case "large":
							colWidth =  $("#pageContents").width() * 0.75;
							break;
						case "full":
							colWidth =  $("#pageContents").width();
							break;
					}
					break;
			}
			/*
			if(fixedCols.length>0){
				colWidth = colWidth - (colWidth/6)
				colWidth = colWidth/(row.length-1);
			}else{
				colWidth = colWidth - (colWidth/6)
				colWidth = colWidth/row.length;
			}
			*/
			colWidth = colWidth - (colWidth/6)
			colWidth = colWidth/(row.length-1);
			$grid.css('width', colWidth)

			if (x_currentPageXML.getAttribute("constrain") == "col") {
				for (i=0; i<data.length; i++) {
					row = data[i].split(separator);
					$tr = $('<tr/>').appendTo($gridBorders);

					if (i == 0) {
						$cols = $('<colgroup>').appendTo($gridBorders);
						for (j=0; j<row.length; j++) {
							$holder = $('<div class="listHolder constrainC"></div>').appendTo($grid);
							$('<ul></ul>').appendTo($holder);
							$('<col>').appendTo($cols)
							labelData.push([]);
						}
					}
					for (j=0; j<row.length; j++) {
						this.addLabel(row[j], $grid.find(".listHolder:eq(" + j + ") ul"), i, j);
						$tr.append('<td/>');
					}
				}

				// labels on each column should be same width & all labels should be same height...
				var maxW, maxH = 0;
				$grid.find("ul").each(function() {
					maxW = 0;
					$(this).find("li").each(function(i) {
						maxW = Math.max(maxW, $(this).width());
						if ($.inArray(i,fixedRows) == -1) {
							maxH = Math.max(maxH, $(this).height());
						}
					}).width(maxW + 5 + "px");
				}).find("li")
					.height(maxH + "px");

				// ...unless they're in a fixed row when they must just have same height as other labels on that row
				for (i=0; i<fixedRows.length; i++) {
					maxH = 0;
					var $labels = $([]);
					$grid.find("ul li.static").each(function() {
						if ($(this).data("xy")[1] == fixedRows[i]) {
							$(this).css("height", "");
							maxH = Math.max(maxH, $(this).height());
						}
					});
					$grid.find("ul li.static").each(function() {
						if ($(this).data("xy")[1] == fixedRows[i]) {
							$(this).css("height", maxH);
						}
					});
					$labels.height(maxH);
				}


			} else if (x_currentPageXML.getAttribute("constrain") == "row") {
				for (i=0; i<data.length; i++) {
					$holder = $('<div class="listHolder constrainR"></div>').appendTo($grid);
					$ul = $('<ul/>').appendTo($holder);
					labelData.push([]);
					row = data[i].split(separator);
					$tr = $('<tr/>').appendTo($gridBorders);
					if (i == 0) {
						$cols = $('<colgroup>').appendTo($gridBorders);
						for (j=0; j<row.length; j++) {
							$('<col>').appendTo($cols)
						}
					}

					for (j=0; j<row.length; j++) {
						this.addLabel(row[j], $ul, i, j);
						$tr.append('<td/>');
					}
				}

				// labels on each row should be same height & all labels should be same width...
				var maxW = 0, maxH;
				$grid.find("ul").each(function() {
					maxH = 0;
					$(this).find("li").each(function(i) {
						maxH = Math.max(maxH, $(this).height());
						if ($.inArray(i,fixedCols) == -1) {
							maxW = Math.max(maxW, $(this).width());
						}
					}).height(maxH + "px");
				}).find("li")
					.width(maxW + 5 + "px");

				// ...unless they're in a fixed column when they must just have same width as other labels on that column
				for (i=0; i<fixedCols.length; i++) {
					maxW = 0;
					$grid.find("ul").find("li:eq(" + fixedCols[i] + ")").each(function() {
						$(this).css("width", "");
						maxW = Math.max(maxW, $(this).width());
					}).width(maxW + 5 + "px");
				}

			} else {
				debugger;
				$holder = $('<div class="listHolder"></div>').appendTo($grid);
				$ul = $('<ul/>').appendTo($holder);
				labelData.push([]);

				for (i=0; i<data.length; i++) {
					row = data[i].split(separator);
					$tr = $('<tr/>').appendTo($gridBorders);
					if (i == 0) {
						$cols = $('<colgroup>').appendTo($gridBorders);
						for (j=0; j<row.length; j++) {
							$('<col>').appendTo($cols)
						}
					}

					for (j=0; j<row.length; j++) {
						this.addLabel(row[j], $ul, i, j);
						$tr.append('<td/>');
					}
				}

				// every label should be same width & height...
				var maxW = 0, maxH = 0;

				$grid.find("ul li").each(function(i) {
					if ($.inArray($(this).data("xy")[0],fixedCols) == -1) {
						maxW = Math.max(maxW, $(this).width());
					}
					if ($.inArray(i,fixedRows) == -1) {
						maxH = Math.max(maxH, $(this).height());
					}
				})
				  .width(maxW + 5 + "px")
				  .height(maxH + "px");

				// ...unless they're in a fixed column/row when they must just have same width/height as other labels on that column/row
				for (i=0; i<fixedCols.length; i++) {
					maxW = 0;
					var $labels = $([]);
					$grid.find("ul li.static").each(function() {
						if ($(this).data("xy")[0] == fixedCols[i]) {
							$(this).css("width", "");
							maxW = Math.max(maxW, $(this).width());
							if ($labels == undefined) { $labels = $(this); } else { $labels = $labels.add($(this));}
						}
					});
					$labels.width(maxW + 5 + "px");
				}

				for (i=0; i<fixedRows.length; i++) {
					maxH = 0;
					var $labels = $([]);
					$grid.find("ul li.static").each(function() {
						if ($(this).data("xy")[1] == fixedRows[i]) {
							$(this).css("height", "");
							maxH = Math.max(maxH, $(this).height());
							if ($labels == undefined) { $labels = $(this) } else { $labels = $labels.add($(this)); }
						}
					});
					$labels.height(maxH);
				}
			}

			$pageContents.data("labelData", labelData);

			// insert rows & cells that make up grid borders (has to be overlaid as the swapping of labels would be too complicated if labels were really in the table)
			$gridBorders.insertBefore($grid);

			// fix width of grid so the correct amount of labels are on each row
			if (x_currentPageXML.getAttribute("constrain") != "col") {
				var $li = $grid.find("li"),
					rowW = 0;
				for (i=0; i<data[0].split(separator).length; i++) {
					rowW += $grid.find("li:eq(" + i + ")").width();
				}
				$grid.find("ul").width(rowW + (((parseInt($li.css("padding-left")) + parseInt($li.css("margin-left")) + parseInt($li.css("border-left-width"))) * 2) * data[0].split(separator).length));
			}

			// style borders & match their size to grid labels
			if (x_currentPageXML.getAttribute("style") != "none") {
				$gridBorders.addClass(x_currentPageXML.getAttribute("style"));

				if (x_currentPageXML.getAttribute("constrain") != "col") {
					$gridBorders.width($grid.find("ul:eq(0)").width());
					$gridBorders.find("col").each(function(i) {
						$(this).width($grid.find("ul:eq(0) li:eq(" + i + ")").width());
					});

					if (x_currentPageXML.getAttribute("constrain") == "row") {
						$gridBorders.find("tr").each(function(i) {
							$(this).height($grid.find("ul:eq(" + i + ") li:eq(0)").outerHeight(true));
						});
					} else {
						var num = data[0].split(separator).length;
						$gridBorders.find("tr").each(function(i) {
							rowW += $grid.find("li:eq(" + i + ")").width();
							$(this).height($grid.find("li:eq(" + i * num + ")").outerHeight(true));
						});
					}
				} else {
					var totalW = 0;
					$grid.find("ul").each(function() {
						totalW += $(this).width();
					});
					$gridBorders
						.width(totalW)
						.find("col").each(function(i) {
							$(this).width($grid.find("ul:eq(" + i + ") li:eq(0)").width());
						});
					$gridBorders.find("tr").each(function(i) {
						$(this).height($grid.find("li:eq(" + i + ")").outerHeight(true) - 5);
					});
				}

				// additional styling of table - shade alternative rows / shade headers etc.
				if (x_currentPageXML.getAttribute("shadeHeader") == "true") {
					$gridBorders.addClass("shaded");
				}

				if (x_currentPageXML.getAttribute("shade") == "true") {
					$gridBorders.find("tr").each(function() {
						var $this = $(this),
							thisIndex = $this.index();
						if ($gridBorders.hasClass("header") && $gridBorders.hasClass("shaded")) { // shade even no. rows, except for 1st row
							if (thisIndex%2 == 0 && thisIndex != 0) {
								$this.addClass("shaded");
							}
						} else if (thisIndex%2 != 0) { // shade odd no. rows
							$this.addClass("shaded");
						}
					});
				}

				if ((x_currentPageXML.getAttribute("header") == "col" || x_currentPageXML.getAttribute("header") == "both") && x_currentPageXML.getAttribute("shadeHeader") == "true") {
					$gridBorders.find("tr td:first-child").addClass("header");
				}

				$grid.width($gridBorders.width() + 2);

			} else {
				$gridBorders.remove();
				if (x_currentPageXML.getAttribute("constrain") != "col") {
					$grid.width($grid.find("ul:eq(0)").width());
				} else {
					var totalW = 0;
					$grid.find("ul").each(function() {
						totalW += $(this).width();
					});
					$grid.width(totalW);
				}
			}

			$("#gridHolder")
				.width($grid.width())
				.height($grid.height());

			if (align == 'top')
			{
				$("#gridHolder").css("margin", "10px auto auto");
			}

			if (align == 'right')
			{
				$('#otherContent').css('width', $('#pageContents').width() - $grid.width());
			}

			this.randomiseLabels();

			// create duplicate labels used to show previews when dragging the real labels
			$grid.find("ul").each(function() {
				$(this).clone()
					.insertBefore($(this))
					.addClass("preview")
					.find("li")
						.css("visibility", "hidden")
						.removeClass("shadow");
			});

			// this uses draggable & droppable rather than sortable as sortable doesn't deal with fixed labels well
			$grid
				.find("ul:not(.preview) li:not(.static)")
					.draggable({
						stack:	"#grid ul:not(.preview) li", // item being dragged is always on top (z-index)
						revert:	"invalid", // snap back to original position if not dropped on target
						start:	function() {
							grid.removeFocus();

							$(this)
								.removeClass("shadow")
								.addClass("panel");

							$grid.find(".tick").remove();
						},
						stop:	function() {
							$(this)
								.removeClass("panel")
								.addClass("shadow");
						}
						})

					// set up events used when keyboard rather than mouse is used
					.on("focusin", function() {
						var $this = $(this);
						if ($pageContents.data("selectedLabel") != undefined && $pageContents.data("selectedLabel") != "") { // a label has been selected...
							if ($this.is($pageContents.data("selectedLabel")) == false) { // ...it's not the label in focus...
								if ($this.parent().is($pageContents.data("selectedLabel").parent())) { // ... and the label in focus can have the selected label dropped on it
									grid.overEvent($this, $pageContents.data("selectedLabel"));
									$this
										.html($pageContents.data("selectedLabel").html())
										.addClass("selected");
								} else {
									$this.addClass("focus");
								}
							}

						} else {
							$this.addClass("focus");
						}
						})
					.on("focusout", function() {
						var $this = $(this);
						$this.removeClass("focus selected");
						if ($pageContents.data("selectedLabel") != undefined && $pageContents.data("selectedLabel") != "" && $this.is($pageContents.data("selectedLabel")) == false) {
							if ($this.parent().is($pageContents.data("selectedLabel").parent())) {
								grid.outEvent($this, 0);
								$this.html(labelData[$("#grid .listHolder").index($this.parents(".listHolder"))][$this.data("correct")]);
							}
						}
						x_pageContentsUpdated();
						})
					.on("keypress", function(e) {
						var charCode = e.charCode || e.keyCode;
						if (charCode == 32) {
							$(this).click();
						}
					})
					.on("click", function() {
						var $this = $(this);
						if ($pageContents.data("selectedLabel") != undefined && $pageContents.data("selectedLabel") != "") { // a label has been selected...
							if ($this.is($pageContents.data("selectedLabel")) == false) { // ...it's not the label in focus...
								if ($this.parent().is($pageContents.data("selectedLabel").parent())) { // ... and the label in focus can have the selected label dropped on it
									$this.html(labelData[$("#grid .listHolder").index($this.parents(".listHolder"))][$this.data("correct")]);

									$pageContents.data("selectedLabel")
										.removeClass("selected")
										.addClass("focus");

									$this.removeClass("focus");
									grid.dropEvent($this, $pageContents.data("selectedLabel"));
								}

							} else {
								$this
									.removeClass("selected")
									.addClass("focus");
							}

							$pageContents.data("selectedLabel", "");

						} else {
							$this
								.removeClass("focus")
								.addClass("selected");

							$pageContents.data("selectedLabel", $this);
						}
					})
					.disableSelection();

			$grid.find("ul:not(.preview) li:not(.static)")
				.droppable({
					accept:	function($dragged) {
						if ($(this).parent()[0] == $dragged.parent()[0]) {
							return true;
						}},
					drop:	function(event, ui) {
						grid.dropEvent($(this), ui.draggable);
						},
					over:	function(event, ui) {
						grid.overEvent($(this), ui.draggable);
						},
					out:	function() {
						grid.outEvent($(this), 200);
					},
					hoverClass:	"ui-state-highlight"
					});

			$grid.find("ul li").css("color",$x_body.css("color")); // override jquery ui style
		}

		this.sortDataRefresh = function (data){

			var $grid = $("#grid"), $ul, $holder, row,
					$gridBorders = $("#gridBorders"), $tr;

			if (x_currentPageXML.getAttribute("constrain") == "col") {
				for (var i=0; i<data.length; i++) {
					row = data[i].split(separator);

					for (var j=0; j<row.length; j++) {
						this.addLabelRefresh(i, j);
					}
				}

			} else if (x_currentPageXML.getAttribute("constrain") == "row") {
				for (i = 0; i < data.length; i++) {
					labelData.push([]);
					row = data[i].split(separator);
					for (j = 0; j < row.length; j++) {
						this.addLabelRefresh(i, j);
					}
				}
			}else{

				for (i=0; i<data.length; i++) {
					row = data[i].split(separator);

					for (j=0; j<row.length; j++) {
						this.addLabelRefresh(i, j);
					}
				}
			}
		}

		this.addLabelRefresh = function (data){

			var row = data[0].split(separator).length;

			$(".listHolder ul:first li").each(function (index){
				$(this).data({
					"correct" : $( this ).index(),
					"xy" : [index%row,Math.floor(index/row)]
				});
			})

		}

		this.addLabel = function(txt, $parent, i, j) {
			var $li = $('<li>' + txt + '</li>')
				.appendTo($parent)
				.addClass("ui-state-default");

			if (i == 0 && (x_currentPageXML.getAttribute("header") == "row" || x_currentPageXML.getAttribute("header") == "both")) {
				$li.addClass("header static");
			} else if (j == 0 && (x_currentPageXML.getAttribute("header") == "col" || x_currentPageXML.getAttribute("header") == "both")) {
				$li.addClass("header static");
			} else {
				if ($.inArray(i,fixedRows) >= 0 || $.inArray(j,fixedCols) >= 0) {
					$li.addClass("static");
				} else {
					for (var k=0; k<fixedCells.length; k++) {
						if (j == fixedCells[k][0] && i == fixedCells[k][1]) {
							$li.addClass("static");
						}
					}
				}
			}

			if (!$li.hasClass("static")) {
				$li
					.addClass("shadow")
					.attr("tabindex", "0");
			}

			$li
			 .data({
				"correct" : $li.index(),
				"xy" : [j,i]
			 });

			labelData[$parent.parent().index()].push(txt);
		}

		// randomise labels (keeping fixed ones in correct place)
		this.randomiseLabels = function() {
			$("#grid").find("ul").each(function(i) {
				var fixedLabels = $(this).find("li.static"),
					$ul = $(this);

				$ul.find("li.static").detach();

				var labels = $ul.children("li");
				labels = x_shuffleArray(labels);
				$ul.children("li").detach();
				for (var i=0; i<labels.length; i++) {
					$ul.append(labels[i]);
				}

				fixedLabels.each(function() {
					if ($ul.find("li").length <= $(this).data("correct")) {
						$ul.append($(this));
					} else {
						$ul.find("li:eq(" + ($(this).data("correct")) + ")").before($(this));
					}
				});
			});
		}

		this.overEvent = function($this, draggable) {
			clearTimeout(timeout);
			var $thisParent = $this.parent();

			if (x_currentPageXML.getAttribute("drag") == "insert") {
				// show preview for all labels that will be moved
				var toPreview = [], newTxt = [],
					indexDrag = draggable.index(),
					indexDrop = $this.index(),
					lowest = Math.min(indexDrop, indexDrag),
					highest = Math.max(indexDrag, indexDrop);

				$this.parent().find("li").css("visibility", "visible");
				$this.parent().prev(".preview").find("li").css("visibility", "hidden");

				for (var i=0; i<highest - lowest + 1; i++) {
					if (!$thisParent.find("li:eq(" + (i + lowest) + ")").hasClass("static")) {
						toPreview.push(i + lowest);
						newTxt.push(i + lowest);
					}
				}
				toPreview.splice(lowest == indexDrag ? toPreview.length-1 : 0, 1);
				newTxt.splice(lowest == indexDrag ? 0 : newTxt.length-1, 1);

				for (i=0; i<toPreview.length; i++) {
					// this ensures that MathJax isn't duplicated next time x_pageContentsUpdated()
					var $labelClone = $thisParent.find("li:eq(" + newTxt[i] + ")").clone();
					$labelClone.find("script[id^='MathJax-Element']").remove();

					$thisParent.prev(".preview").find("li:eq(" + toPreview[i] + ")")
						.html($labelClone.html())
						.css("visibility", "visible");

					var $label = $thisParent.find("li:eq(" + toPreview[i] + ")");
					if ($label[0] != draggable[0]) {
						$label.css("visibility", "hidden");
					}
				}

			} else {
				// show preview for two labels that will be swapped

				// this ensures that MathJax isn't duplicated next time x_pageContentsUpdated()
				var $labelClone = $this.clone();
				$labelClone.find("script[id^='MathJax-Element']").remove();

				$thisParent.prev(".preview").find("li:eq(" + draggable.index() + ")")
					.css("visibility","visible")
					.html($labelClone.html());

				if ($pageContents.data("selectedLabel") != undefined && $pageContents.data("selectedLabel") != "") {
					$pageContents.data("selectedLabel").css("visibility", "hidden");
				}
			}
		}

		this.outEvent = function($this, time) {
			// slight delay in removing previews on roll over to avoid flickers over gaps between labels
			timeout = setTimeout(function () {
				$this.parent().find("li").css("visibility", "visible");
				$this.parent().prev(".preview").find("li").css("visibility", "hidden");
			}, time);
		}

		this.dropEvent = function($this, draggable) {
			this.removeFocus();

			if (x_currentPageXML.getAttribute("drag") == "insert") {
				// insert dragged label into list
				if (draggable.index() > $this.index()) {
					draggable.insertBefore($this);
				} else {
					draggable.insertAfter($this);
				}
				draggable.css({"top":"auto","left":"auto"});

				// adjust position of fixed labels
				var fixedLabels = $this.parent().find("li.static"),
					$ul = $this.parent();

				fixedLabels.detach();
				fixedLabels.each(function() {
					if ($ul.find("li").length <= $(this).data("correct")) {
						$ul.append($(this));
					} else {
						$ul.find("li:eq(" + ($(this).data("correct")) + ")").before($(this));
					}
				});

			} else {
				// swap dragged label with label it's dropped on
				var index = $this.index();
				$this.insertBefore(draggable);
				if ($this.index() < index) {
					draggable.insertAfter($this.parent().find("li")[index]);
				} else if (index != 0) {
					draggable.insertAfter($this.parent().find("li")[index - 1]);
				} else {
					draggable.insertBefore($this.parent().find("li")[index]);
				}

				draggable.css({"top":"auto","left":"auto"});
			}
		}

		this.removeFocus = function() {
			$pageContents.data("selectedLabel", "");

			$("#grid ul.preview li").css("visibility","hidden");
			$("#grid ul:not(.preview) li")
				.css("visibility","visible")
				.blur()
				.removeClass("focus selected");
		}
	//Starting the tracking
	this.initTracking = function() {
		// Track the dictation page
		this.weighting = 1.0;
		if (x_currentPageXML.getAttribute("trackingWeight") != undefined)
		{
			this.weighting = x_currentPageXML.getAttribute("trackingWeight");
		}
		if(x_currentPageXML.getAttribute("judge") != undefined && x_currentPageXML.getAttribute("judge") == 'false'){
			this.weighting= 0.0;
		}

		correctOptions = [];
		correctAnswer = [];
		correctFeedback = [];
		rows = x_currentPageXML.getAttribute("data").split("||");
		rowCount = 1;

		var header = (x_currentPageXML.getAttribute("header") != undefined ? x_currentPageXML.getAttribute("header") : "");
		var fixedCells = (x_currentPageXML.getAttribute("fixedCells") != undefined ? x_currentPageXML.getAttribute("fixedCells") : "");
		var fixedRows = (x_currentPageXML.getAttribute("fixedRows") != undefined ? x_currentPageXML.getAttribute("fixedRows") : "");
		var fixedCols = (x_currentPageXML.getAttribute("fixedCols") != undefined ? x_currentPageXML.getAttribute("fixedCols") : "");

		fixedCells = fixedCells.trim().replace(/ /g, '');
		fixedRows = fixedRows.trim().replace(/ /g, '');
		fixedCols = fixedCols.trim().replace(/ /g, '');

		for(row in rows)
		{
			if (rowCount == 1 && (header == "row" || header == "both"))
			{
				rowCount++;
				continue;
			}
			columnCount = 1;

			columns = rows[row].split("|");
			for(column in columns)
			{
				if (columnCount == 1 && (header == "col" || header == "both"))
				{
					columnCount++;
					continue;
				}
				if(fixedCells.indexOf(columnCount + "," + rowCount) == -1 &&
					fixedRows.indexOf(rowCount) == -1 &&
					fixedCols.indexOf(columnCount) == -1)
				{
					correctAnswer.push(columns[column] + " --> [" + columnCount + "," + rowCount +"]");
					correctFeedback.push("Correct");
					correctOption = {source:columns[column], target: "[" + columnCount + "," + rowCount + "]"};
					correctOptions.push(correctOption);
				}
				columnCount++;

			}
			rowCount++;
		}
		XTSetPageType(x_currentPage, 'numeric', 1, this.weighting);

		var label = x_currentPageXML.getAttribute("name");
		if (x_currentPageXML.getAttribute("trackinglabel") != null && x_currentPageXML.getAttribute("trackinglabel") != "")
		{
			label = x_currentPageXML.getAttribute("trackinglabel");
		}
		XTEnterInteraction(x_currentPage, 0, 'match', label, correctOptions, correctAnswer, correctFeedback, x_currentPageXML.getAttribute("grouping"));
		/*
		for(var i = 0; i < correctOptions.length; i++)
		{
			options = []
			options.push(correctOptions[i])
			XTEnterInteraction(x_currentPage, i, 'match', correctOptions[i].target, options, correctAnswer[i], correctFeedback[i]);
		}
		*/
	}
}

	
	grid.init();
	
</script>


<div id="pageContents">

	<div id="content">
	<div id="otherContent">
		<div id="textHolder"/>
		<div id="feedback" aria-live="polite"/>
	</div>

	<div id="gridHolder">
		<table id="gridBorders"/>
		<div id="grid"/>
	</div>
	</div>
	<div id="btnHolder">
		<button id="checkBtn" class=""></button>
	</div>

	
</div>
